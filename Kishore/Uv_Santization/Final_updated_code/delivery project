#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <Firebase_ESP_Client.h>
#include <ctype.h>  // for toupper

// ---------- WiFi / Firebase ----------
#define WIFI_SSID     "smart"
#define WIFI_PASSWORD "123456789"

#define API_KEY       "AIzaSyBi4imuMT5imCT-8IBULdyFqj-ZZtl68Do"
#define DATABASE_URL  "https://regal-welder-453313-d6-default-rtdb.firebaseio.com"
#define USER_EMAIL    "spherenexgpt@gmail.com"
#define USER_PASSWORD "Spherenex@123"

// If your relay is "LOW-level trigger" (IN pulled LOW = ON), keep true.
#define RELAY_ACTIVE_LOW  true

// Firebase objects
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// ---------- Pin Mapping ----------
// L298N motor pins (NodeMCU labels)
const int IN1 = D1;  // GPIO5
const int IN2 = D2;  // GPIO4
const int IN3 = D5;  // GPIO14
const int IN4 = D6;  // GPIO12

// Single relay pin (UV relay)
const int RELAY_UV = D7;  // GPIO13 -> relay IN

// Ultrasonic sensor pins (HC-SR04)
const int TRIG_PIN = D3;  // GPIO0  -> HC-SR04 TRIG (output)
const int ECHO_PIN = D4;  // GPIO2  -> HC-SR04 ECHO (input via divider)

// Obstacle threshold (cm)
const float OBSTACLE_THRESHOLD_CM = 15.0;

// Timing
const unsigned long POLL_MS = 250;
unsigned long lastPoll = 0;

// State trackers
char desiredDir    = 'S';    // last commanded direction from Firebase
char lastMotorCmd  = 'X';    // last motor command actually applied
int  lastRelayVal  = -1;     // last Relay value from Firebase (0 or 1)

// Mode: 'M' = Manual, 'A' = Auto
char currentMode   = 'M';

// Obstacle logic
bool obstacleActive        = false;  // current obstacle state (from sensor)
bool lastObstacleActive    = false;  // previous obstacle state
char dirBeforeObstacle     = 'S';    // direction just before obstacle was detected

// Auto-mode avoidance
bool autoAvoidActive       = false;
unsigned long autoAvoidStart = 0;

// ---------- Motor helpers ----------
void stopMotors() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
}

void driveForward() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void driveBackward() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void turnLeft() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void turnRight() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void applyCommand(char c) {
  switch (c) {
    case 'F': driveForward();  break;
    case 'B': driveBackward(); break;
    case 'L': turnLeft();      break;
    case 'R': turnRight();     break;
    case 'S':
    default:  stopMotors();    break;
  }
  lastMotorCmd = c;
  Serial.printf("[MOTOR] Command applied: %c\n", c);
}

// ---------- Relay helpers ----------
void relayWrite(bool on) {
  if (RELAY_ACTIVE_LOW) {
    digitalWrite(RELAY_UV, on ? LOW : HIGH);
  } else {
    digitalWrite(RELAY_UV, on ? HIGH : LOW);
  }
}

// ---------- Ultrasonic helpers ----------
float readUltrasonicCM() {
  // Ensure trigger is LOW
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);

  // 10us HIGH pulse to trigger
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  // Measure echo pulse width (timeout 30ms)
  unsigned long duration = pulseIn(ECHO_PIN, HIGH, 30000UL);
  if (duration == 0) {
    // No echo (too far or no object)
    return -1.0;
  }

  // Speed of sound ~343 m/s => 29.1 us per cm round-trip
  float distance_cm = (float)duration / 58.0;  // standard HC-SR04 formula
  return distance_cm;
}

void handleObstacle() {
  float dist = readUltrasonicCM();
  bool nowObstacle = false;

  if (dist > 0 && dist <= OBSTACLE_THRESHOLD_CM) {
    nowObstacle = true;
  }

  obstacleActive = nowObstacle;

  // If state changed, update Firebase and handle mode-specific logic
  if (nowObstacle != lastObstacleActive) {
    lastObstacleActive = nowObstacle;

    // Update /UV_Sanitization/Obstacle (1 = obstacle, 0 = clear)
    if (Firebase.ready()) {
      if (Firebase.RTDB.setInt(&fbdo, "/UV_Sanitization/Obstacle", nowObstacle ? 1 : 0)) {
        Serial.printf("[OBSTACLE] Firebase Obstacle set to %d\n", nowObstacle ? 1 : 0);
      } else {
        Serial.printf("[OBSTACLE] Failed to set Obstacle: %s\n",
                      fbdo.errorReason().c_str());
      }
    }

    // ---- Manual mode behaviour (original logic) ----
    if (currentMode == 'M') {
      if (nowObstacle) {
        // Obstacle detected: remember current direction and stop
        dirBeforeObstacle = desiredDir;
        Serial.printf("[OBSTACLE] (MANUAL) Detected at %.2f cm. Stopping motors, Direction=S\n",
                      dist);

        applyCommand('S');

        // Also reflect Direction = "S" in Firebase
        if (Firebase.ready()) {
          if (Firebase.RTDB.setString(&fbdo, "/UV_Sanitization/Direction", "S")) {
            Serial.println("[OBSTACLE] (MANUAL) Direction set to 'S' in Firebase");
          } else {
            Serial.printf("[OBSTACLE] (MANUAL) Failed to set Direction to S: %s\n",
                          fbdo.errorReason().c_str());
          }
        }
        desiredDir = 'S';  // local desired also S while obstacle present
      } else {
        // Obstacle cleared: restore previous direction
        Serial.printf("[OBSTACLE] (MANUAL) Cleared (last dist=%.2f). Restoring previous direction: %c\n",
                      dist, dirBeforeObstacle);

        desiredDir = dirBeforeObstacle;
        applyCommand(desiredDir);

        // Also update Direction in Firebase back to previous direction
        if (Firebase.ready()) {
          String dirStr;
          dirStr += desiredDir;
          if (Firebase.RTDB.setString(&fbdo, "/UV_Sanitization/Direction", dirStr)) {
            Serial.printf("[OBSTACLE] (MANUAL) Direction restored to '%c' in Firebase\n", desiredDir);
          } else {
            Serial.printf("[OBSTACLE] (MANUAL) Failed to restore Direction: %s\n",
                          fbdo.errorReason().c_str());
          }
        }
      }
    }
    // ---- Auto mode: just log; movement handled in handleAutoMode() ----
    else if (currentMode == 'A') {
      if (!nowObstacle) {
        Serial.printf("[OBSTACLE] (AUTO) Cleared (last dist=%.2f).\n", dist);
      } else {
        Serial.printf("[OBSTACLE] (AUTO) Detected at %.2f cm.\n", dist);
      }
    }
  } else {
    // No state change
    if (currentMode == 'M') {
      // In manual mode, still enforce stop while obstacle exists
      if (nowObstacle && lastMotorCmd != 'S') {
        applyCommand('S');
      }
    }
    // In auto mode, obstacle handling is done in handleAutoMode()
  }
}

// ---------- Setup blocks ----------
void setupPins() {
  // Motors
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  stopMotors();

  // Relay
  pinMode(RELAY_UV, OUTPUT);
  relayWrite(false);   // relay OFF initially

  // Ultrasonic
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  digitalWrite(TRIG_PIN, LOW);
}

void setupWiFi() {
  Serial.printf("\n[WiFi] Connecting to %s", WIFI_SSID);
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
    delay(400);
    Serial.print('.');
  }
  Serial.printf("\n[WiFi] Connected. IP: %s\n", WiFi.localIP().toString().c_str());
}

// Create default nodes in Firebase if they don't exist
void initFirebaseNodes() {
  Serial.println("[Firebase] Initializing /UV_Sanitization nodes...");

  // Direction = "S" (stop)
  if (Firebase.RTDB.setString(&fbdo, "/UV_Sanitization/Direction", "S")) {
    Serial.println("[Firebase] /UV_Sanitization/Direction = \"S\" (OK)");
    desiredDir = 'S';
  } else {
    Serial.printf("[Firebase] Failed to set Direction: %s\n",
                  fbdo.errorReason().c_str());
  }

  // Relay = 1 (OFF) => relay OFF initially
  if (Firebase.RTDB.setInt(&fbdo, "/UV_Sanitization/Relay", 1)) {
    Serial.println("[Firebase] /UV_Sanitization/Relay = 1 (OFF) (OK)");
    lastRelayVal = 1;
  } else {
    Serial.printf("[Firebase] Failed to set Relay: %s\n",
                  fbdo.errorReason().c_str());
  }

  // Obstacle = 0 (no obstacle initially)
  if (Firebase.RTDB.setInt(&fbdo, "/UV_Sanitization/Obstacle", 0)) {
    Serial.println("[Firebase] /UV_Sanitization/Obstacle = 0 (OK)");
  } else {
    Serial.printf("[Firebase] Failed to set Obstacle: %s\n",
                  fbdo.errorReason().c_str());
  }

  // Mode = "M" (Manual) by default
  if (Firebase.RTDB.setString(&fbdo, "/UV_Sanitization/Mode", "M")) {
    Serial.println("[Firebase] /UV_Sanitization/Mode = \"M\" (Manual) (OK)");
    currentMode = 'M';
  } else {
    Serial.printf("[Firebase] Failed to set Mode: %s\n",
                  fbdo.errorReason().c_str());
  }
}

void setupFirebase() {
  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;

  auth.user.email    = USER_EMAIL;
  auth.user.password = USER_PASSWORD;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);
  Serial.println("[Firebase] Started with email/password auth");

  unsigned long start = millis();
  while (!Firebase.ready() && millis() - start < 15000) {
    Serial.println("[Firebase] Waiting for ready...");
    delay(500);
  }

  if (Firebase.ready()) {
    Serial.println("[Firebase] Ready. Initializing nodes...");
    initFirebaseNodes();
  } else {
    Serial.println("[Firebase] Not ready, could not init nodes");
  }
}

// ---------- Pollers ----------

// /UV_Sanitization/Direction -> F/B/L/R/S (used only in Manual mode)
void pollDirection() {
  if (!Firebase.ready()) return;

  if (Firebase.RTDB.getString(&fbdo, "/UV_Sanitization/Direction")) {
    String val = fbdo.stringData();
    val.trim();
    if (val.length() == 0) return;

    char c = toupper(val.charAt(0));
    if (c != 'F' && c != 'B' && c != 'L' && c != 'R' && c != 'S') {
      c = 'S';
    }

    if (c != desiredDir) {
      desiredDir = c;
      Serial.printf("[DIR] Desired direction from Firebase: %c\n", desiredDir);
    }

    // If no obstacle, apply the commanded direction
    if (!obstacleActive && desiredDir != lastMotorCmd) {
      applyCommand(desiredDir);
    }
    // If obstacleActive, motors are already handled in handleObstacle()
  } else {
    Serial.printf("[Firebase] Direction read err: %s\n",
                  fbdo.errorReason().c_str());
  }
}

// /UV_Sanitization/Relay -> 0: relay ON, 1: relay OFF
void pollRelay() {
  if (!Firebase.ready()) return;

  int relayVal = -9999;
  bool hasValue = false;

  // Try int first
  if (Firebase.RTDB.getInt(&fbdo, "/UV_Sanitization/Relay")) {
    relayVal = fbdo.intData();
    hasValue = true;
  }
  // If stored as string
  else if (Firebase.RTDB.getString(&fbdo, "/UV_Sanitization/Relay")) {
    String s = fbdo.stringData();
    s.trim();
    if (s.length() > 0) {
      relayVal = s.toInt();
      hasValue = true;
    }
  } else {
    Serial.printf("[Firebase] Relay read err: %s\n",
                  fbdo.errorReason().c_str());
  }

  if (!hasValue) return;

  // Clamp to 0 or 1
  if (relayVal != 0 && relayVal != 1) relayVal = 1; // default OFF

  if (relayVal != lastRelayVal) {
    lastRelayVal = relayVal;

    if (relayVal == 0) {
      // Relay:0 -> relay ON
      relayWrite(true);
      Serial.println("[RELAY] Relay=0 -> Relay ON");
    } else {
      // Relay:1 -> relay OFF
      relayWrite(false);
      Serial.println("[RELAY] Relay=1 -> Relay OFF");
    }
  }
}

// /UV_Sanitization/Mode -> "M" (Manual) or "A" (Auto)
void pollMode() {
  if (!Firebase.ready()) return;

  if (Firebase.RTDB.getString(&fbdo, "/UV_Sanitization/Mode")) {
    String val = fbdo.stringData();
    val.trim();
    if (val.length() == 0) return;

    char m = toupper(val.charAt(0));
    if (m != 'M' && m != 'A') {
      m = 'M';
    }

    if (m != currentMode) {
      currentMode = m;
      Serial.printf("[MODE] Mode changed to %c\n", currentMode);

      // On mode switch, reset avoidance
      autoAvoidActive = false;

      if (currentMode == 'A') {
        // Start with forward motion (default)
        applyCommand('F');
        if (Firebase.ready()) {
          Firebase.RTDB.setString(&fbdo, "/UV_Sanitization/Direction", "F");
        }
      } else {
        // Manual mode: apply whatever is desiredDir
        Serial.println("[MODE] Switched to MANUAL, applying desiredDir");
        applyCommand(desiredDir);
      }
    }
  } else {
    Serial.printf("[Firebase] Mode read err: %s\n",
                  fbdo.errorReason().c_str());
  }
}

// ---------- Auto Mode Movement Logic ----------
void handleAutoMode() {
  // In AUTO mode:
  // - Default: move FORWARD
  // - If Relay == 1 OR Obstacle == 1 (any one is 1),
  //   then turn LEFT for 5 seconds, then FORWARD again.

  // If we are currently in avoidance phase
  if (autoAvoidActive) {
    unsigned long now = millis();
    // Finish avoidance strictly after 5 seconds
    if (now - autoAvoidStart >= 5000UL) {
      autoAvoidActive = false;
      Serial.println("[AUTO] Avoidance done. Moving FORWARD again.");
      applyCommand('F');
      if (Firebase.ready()) {
        Firebase.RTDB.setString(&fbdo, "/UV_Sanitization/Direction", "F");
      }
    } else {
      // Keep turning left
      if (lastMotorCmd != 'L') {
        applyCommand('L');
        if (Firebase.ready()) {
          Firebase.RTDB.setString(&fbdo, "/UV_Sanitization/Direction", "L");
        }
      }
    }
    return;
  }

  // Not currently avoiding -> check trigger condition
  bool trigger = (lastRelayVal == 1 || obstacleActive);

  if (trigger) {
    // Start avoidance: LEFT for 5 seconds
    autoAvoidActive = true;
    autoAvoidStart = millis();
    Serial.println("[AUTO] Triggered (Relay==1 OR Obstacle==1). Starting LEFT for 5 seconds.");
    applyCommand('L');
    if (Firebase.ready()) {
      Firebase.RTDB.setString(&fbdo, "/UV_Sanitization/Direction", "L");
    }
  } else {
    // Normal case: go forward
    if (lastMotorCmd != 'F') {
      applyCommand('F');
      if (Firebase.ready()) {
        Firebase.RTDB.setString(&fbdo, "/UV_Sanitization/Direction", "F");
      }
    }
  }
}

// ---------- Arduino ----------
void setup() {
  Serial.begin(115200);
  setupPins();
  setupWiFi();
  setupFirebase();
  Serial.println("[SYS] Ready. Watching /UV_Sanitization/Mode, Direction, Relay, Obstacle...");
}

void loop() {
  unsigned long now = millis();
  if (now - lastPoll >= POLL_MS) {
    lastPoll = now;

    // 1) Always know the current mode
    pollMode();

    // 2) Check ultrasonic and update Obstacle state + Firebase
    handleObstacle();

    // 3) Always poll Relay (used in both modes)
    pollRelay();

    // 4) Mode-specific motor control
    if (currentMode == 'M') {
      // Manual mode: same behaviour as original code
      pollDirection();
      // handleObstacle() already handles stop/restore in MANUAL
    } else {
      // AUTO mode: ignore manual Direction commands and handle logic here
      handleAutoMode();
    }
  }
}
