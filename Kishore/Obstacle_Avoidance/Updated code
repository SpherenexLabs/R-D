/*
  UNO + L293D + HC-SR04
  Always forward.

  Obstacle logic (alternating):
    1st obstacle  -> back 2s -> RIGHT 2s -> forward
    2nd obstacle  -> back 2s -> LEFT  2s -> forward
    3rd obstacle  -> back 2s -> RIGHT 2s -> forward
    ... and so on
*/

#define TRIG_PIN 9
#define ECHO_PIN 10

#define ENA 5
#define IN1 2
#define IN2 3

#define ENB 6
#define IN3 4
#define IN4 7

const int THRESHOLD_CM = 20;
const int SPEED_FWD  = 200;
const int SPEED_TURN = 180;
const int SPEED_BACK = 200;

const unsigned long AVOID_COOLDOWN_MS = 700;
unsigned long lastAvoidTime = 0;

bool nextTurnRight = true;   // 1st time = right, 2nd time = left, alternating

long readDistanceCM() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH, 30000);
  if (duration == 0) return 999;
  return (duration * 343L) / 20000L;
}

void setSpeed(int a, int b) {
  analogWrite(ENA, constrain(a, 0, 255));
  analogWrite(ENB, constrain(b, 0, 255));
}

void forward(int spd) {
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
  setSpeed(spd, spd);
}

void backward(int spd) {
  digitalWrite(IN1, LOW);  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);  digitalWrite(IN4, HIGH);
  setSpeed(spd, spd);
}

void turnRight(int spd) {
  // spin right: left forward, right backward
  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);  digitalWrite(IN4, HIGH);
  setSpeed(spd, spd);
}

void turnLeft(int spd) {
  // spin left: left backward, right forward
  digitalWrite(IN1, LOW);  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);
  setSpeed(spd, spd);
}

void setup() {
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  pinMode(ENA, OUTPUT); pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);
  pinMode(ENB, OUTPUT); pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);

  Serial.begin(9600);
  delay(200);

  forward(SPEED_FWD);
}

void loop() {
  long d = readDistanceCM();
  Serial.print("Distance: "); Serial.print(d); Serial.println(" cm");

  // Default: keep moving forward
  forward(SPEED_FWD);

  // Obstacle routine (alternating right/left)
  if (d <= THRESHOLD_CM && (millis() - lastAvoidTime) > AVOID_COOLDOWN_MS) {
    lastAvoidTime = millis();

    backward(SPEED_BACK);
    delay(2000);

    if (nextTurnRight) {
      turnRight(SPEED_TURN);
    } else {
      turnLeft(SPEED_TURN);
    }
    delay(2000);

    forward(SPEED_FWD);

    // Toggle for next obstacle
    nextTurnRight = !nextTurnRight;
  }

  delay(60);
}
