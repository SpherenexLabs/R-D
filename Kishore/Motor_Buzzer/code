#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <Firebase_ESP_Client.h>
#include <ctype.h>  // for toupper

// ============ WIFI CONFIG ===================
#define WIFI_SSID     "robot"        // change if needed
#define WIFI_PASSWORD "123456789"    // change if needed

// ============ FIREBASE CONFIG ================
#define API_KEY       "AIzaSyAXHnvNZkb00PXbG5JidbD4PbRgf7l6Lgg"
#define DATABASE_URL  "https://v2v-communication-d46c6-default-rtdb.firebaseio.com/"

#define USER_EMAIL    "spherenexgpt@gmail.com"
#define USER_PASSWORD "Spherenex@123"

// Firebase objects
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// Helpers from Firebase library examples
#include "addons/TokenHelper.h"
#include "addons/RTDBHelper.h"

// ============ RTDB PATHS =====================
const char* PATH_DIRECTION = "/Motor_Buzzer/direction";
const char* PATH_OBSTACLE  = "/Motor_Buzzer/Obstacle";
const char* PATH_BUZZ      = "/Motor_Buzzer/Buzz";

// ============ PIN CONFIG =====================
// NodeMCU / ESP8266

// Ultrasonic sensor (HC-SR04)
#define TRIG_PIN   D1      // GPIO5
#define ECHO_PIN   D2      // GPIO4  (through voltage divider from 5V echo)

// L293D motor driver (two DC motors)
#define IN1        D5      // GPIO14 -> L293D IN1
#define IN2        D6      // GPIO12 -> L293D IN2
#define IN3        D7      // GPIO13 -> L293D IN3
#define IN4        D8      // GPIO15 -> L293D IN4

// Buzzer
#define BUZZER_PIN D3      // GPIO0

// ============ PARAMETERS =====================
const float OBSTACLE_THRESHOLD_CM = 20.0;  // obstacle distance in cm

// Direction states
char requestedDirection = 'S';   // value read from Firebase (F, B, L, R, S)
char activeDirection    = 'S';   // what motors are currently doing

// Obstacle tracking (only for reducing RTDB writes)
bool lastObstacle = false;

// Buzzer tracking
bool buzzActive = false;
unsigned long buzzStartMillis = 0;

// Timing for Firebase loop
unsigned long lastFbMillis = 0;
const unsigned long FB_INTERVAL = 300;  // ms

// --------------------------------------------------
// Ultrasonic distance function
// --------------------------------------------------
float readDistanceCM() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  // timeout ~25ms (~4m distance)
  long duration = pulseIn(ECHO_PIN, HIGH, 25000);
  if (duration == 0) {
    return -1.0; // no echo
  }
  float distance = duration * 0.0343f / 2.0f;
  return distance;
}

// --------------------------------------------------
// Motor control helpers
// --------------------------------------------------
void stopMotors() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
}

void moveForward() {
  // Motor A forward, Motor B forward
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);

  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void moveBackward() {
  // Motor A backward, Motor B backward
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);

  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void moveLeft() {
  // Turn left: left motor backward, right motor forward
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);

  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void moveRight() {
  // Turn right: left motor forward, right motor backward
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);

  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void applyDirection(char dir) {
  switch (dir) {
    case 'F':
      moveForward();
      break;
    case 'B':
      moveBackward();
      break;
    case 'L':
      moveLeft();
      break;
    case 'R':
      moveRight();
      break;
    case 'S':
    default:
      stopMotors();
      break;
  }
}

// --------------------------------------------------
// Setup
// --------------------------------------------------
void setup() {
  Serial.begin(115200);
  Serial.println();
  Serial.println("Motor + Buzzer + Ultrasonic + Firebase");

  // Pin modes
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);

  stopMotors();
  digitalWrite(BUZZER_PIN, LOW);

  // WiFi
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  Serial.print("Connected, IP: ");
  Serial.println(WiFi.localIP());

  // Firebase config
  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;

  auth.user.email    = USER_EMAIL;
  auth.user.password = USER_PASSWORD;

  config.token_status_callback = tokenStatusCallback;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);

  // Initialize default RTDB values
  Firebase.RTDB.setString(&fbdo, PATH_DIRECTION, "S");
  Firebase.RTDB.setInt(&fbdo, PATH_OBSTACLE, 0);
  Firebase.RTDB.setInt(&fbdo, PATH_BUZZ, 0);
}

// --------------------------------------------------
// Loop
// --------------------------------------------------
void loop() {
  unsigned long now = millis();

  // Handle ongoing buzzer (non-blocking)
  if (buzzActive) {
    if (now - buzzStartMillis >= 5000) {
      // 5 seconds over
      digitalWrite(BUZZER_PIN, LOW);
      buzzActive = false;

      // Reset Buzz node to 0
      if (Firebase.ready()) {
        Firebase.RTDB.setInt(&fbdo, PATH_BUZZ, 0);
      }
    }
  }

  // Throttle Firebase operations
  if (!Firebase.ready()) {
    return;
  }
  if (now - lastFbMillis < FB_INTERVAL) {
    return;
  }
  lastFbMillis = now;

  // ---------------------------
  // 1) Read direction
  // ---------------------------
  if (Firebase.RTDB.getString(&fbdo, PATH_DIRECTION)) {
    String d = fbdo.stringData();
    if (d.length() > 0) {
      char c = toupper(d.charAt(0));
      if (c == 'F' || c == 'B' || c == 'L' || c == 'R' || c == 'S') {
        requestedDirection = c;
      }
    }
  } else {
    Serial.print("Failed to get direction, reason: ");
    Serial.println(fbdo.errorReason());
  }

  // ---------------------------
  // 2) Handle Buzz command
  // ---------------------------
  if (!buzzActive) {
    if (Firebase.RTDB.getInt(&fbdo, PATH_BUZZ)) {
      int b = fbdo.intData();
      if (b == 1) {
        // Start buzzer for 5 seconds
        buzzActive = true;
        buzzStartMillis = now;
        digitalWrite(BUZZER_PIN, HIGH);
      }
    } else {
      Serial.print("Failed to get Buzz, reason: ");
      Serial.println(fbdo.errorReason());
    }
  }

  // ---------------------------
  // 3) Ultrasonic & obstacle (ONLY log to Firebase)
  // ---------------------------
  float distance = readDistanceCM();
  bool obstacleNow = false;

  if (distance > 0 && distance <= OBSTACLE_THRESHOLD_CM) {
    obstacleNow = true;
  }

  // Only update RTDB when state changes
  if (obstacleNow != lastObstacle) {
    lastObstacle = obstacleNow;
    int obsFlag = obstacleNow ? 1 : 0;
    Serial.print("Obstacle state changed: ");
    Serial.println(obsFlag);
    Firebase.RTDB.setInt(&fbdo, PATH_OBSTACLE, obsFlag);
  }

  // ---------------------------
  // 4) Normal direction control (NO obstacle effect)
  // ---------------------------
  if (requestedDirection != activeDirection) {
    Serial.print("Direction changed to: ");
    Serial.println(requestedDirection);

    applyDirection(requestedDirection);
    activeDirection = requestedDirection;
  }

  // small delay to keep loop sane
  delay(10);
}
