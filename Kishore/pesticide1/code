/************************************************************
 * Pesticide Spray Robot
 * ESP8266 + L298N + 3-Relay + HC-SR04
 *
 * Firebase RTDB structure (under root node "Pesticide"):
 *   /Pesticide1/direction -> "F","B","L","R","S"
 *       F = Forward
 *       B = Backward
 *       L = Left
 *       R = Right
 *       S = Stop
 *
 *   /Pesticide1/Spray     -> 0,1,2,3
 *       0 = All OFF
 *       1 = Relay1 ON (Spray1)
 *       2 = Relay2 ON (Spray2)
 *       3 = Relay3 ON (Spray3)
 *
 *   /Pesticide1/Obstacle  -> 0,1 (written by ESP)
 *       0 = No obstacle
 *       1 = Obstacle detected
 ************************************************************/

#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <Firebase_ESP_Client.h>

// Helpers from Firebase examples
#include "addons/TokenHelper.h"
#include "addons/RTDBHelper.h"

// ---- Prototypes (not strictly needed, but OK) ----
void setup();
void loop();

// ================= WIFI CONFIG ======================
#define WIFI_SSID     "spray"        // change as needed
#define WIFI_PASSWORD "123456789"    // change as needed

// ================= FIREBASE CONFIG ==================
#define API_KEY       "AIzaSyAXHnvNZkb00PXbG5JidbD4PbRgf7l6Lgg"
#define DATABASE_URL  "https://v2v-communication-d46c6-default-rtdb.firebaseio.com/"

#define USER_EMAIL    "spherenexgpt@gmail.com"
#define USER_PASSWORD "Spherenex@123"

FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// ================= NODE PATHS =======================
// Root node: "Pesticide1"
const String ROOT_NODE    = "/Pesticide1";
const String PATH_DIR     = ROOT_NODE + "/direction";
const String PATH_OBS     = ROOT_NODE + "/Obstacle";
const String PATH_SPRAY   = ROOT_NODE + "/Spray";

// ================ MOTOR DRIVER PINS =================
// L298N: IN1, IN2, IN3, IN4
const int IN1 = D1;   // GPIO5  - Left motor IN1
const int IN2 = D2;   // GPIO4  - Left motor IN2
const int IN3 = D5;   // GPIO14 - Right motor IN3
const int IN4 = D6;   // GPIO12 - Right motor IN4

// ================ RELAY PINS (SPRAY) ================
const int RELAY1_PIN = D7;  // GPIO13 - Spray 1
const int RELAY2_PIN = D0;  // GPIO16 - Spray 2
const int RELAY3_PIN = D4;  // GPIO2  - Spray 3

// Most 5V relay modules are ACTIVE-LOW
#define RELAY_ACTIVE_LOW  true

// ================ ULTRASONIC PINS ===================
// TRIG: D3 (GPIO0) as OUTPUT
// ECHO: D8 (GPIO15) as INPUT (idle LOW, which is good for boot)
const int TRIG_PIN = D3;   // GPIO0 - HC-SR04 TRIG (output)
const int ECHO_PIN = D8;   // GPIO15 - HC-SR04 ECHO (input via divider)

// Obstacle detection threshold
const float OBSTACLE_THRESHOLD_CM = 20.0;  // adjust as needed

// ================ STATE VARIABLES ===================
String currentDirection      = "S";  // what we currently drive to motors
String lastNonStopDirection  = "S";  // last F/B/L/R command (for resume)
bool   obstacleActive        = false;

// true  = user manually set S (manual stop)
// false = we can auto-resume when obstacle clears
bool   manualStop            = false;

// true  = the latest "S" in Firebase was written by obstacle auto-stop
// false = "S" came from user or from normal use
bool   autoStopFromObstacle  = false;

// Timers
unsigned long lastFirebaseReadMs   = 0;
unsigned long lastObstacleCheckMs  = 0;

const unsigned long FIREBASE_READ_INTERVAL_MS  = 300;   // read direction/Spray
const unsigned long OBSTACLE_CHECK_INTERVAL_MS = 150;   // ultrasonic

// ====================================================
// Utility: Relay ON/OFF wrappers
// ====================================================
void setRelay(int pin, bool on)
{
  int level;
  if (RELAY_ACTIVE_LOW)
    level = on ? LOW : HIGH;
  else
    level = on ? HIGH : LOW;

  digitalWrite(pin, level);
}

// ====================================================
// Motor control helpers
// ====================================================
void motorsStop()
{
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
}

void motorsForward()
{
  // Left motor forward
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  // Right motor forward
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void motorsBackward()
{
  // Left motor backward
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  // Right motor backward
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void motorsLeft()
{
  // Turn on spot: left backward, right forward
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void motorsRight()
{
  // Turn on spot: left forward, right backward
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

// Apply currentDirection to motors, considering obstacle & manual stop
void updateMotors()
{
  if (obstacleActive) {
    motorsStop();
    return;
  }

  if (manualStop || currentDirection == "S") {
    motorsStop();
  } else if (currentDirection == "F") {
    motorsForward();
  } else if (currentDirection == "B") {
    motorsBackward();
  } else if (currentDirection == "L") {
    motorsLeft();
  } else if (currentDirection == "R") {
    motorsRight();
  } else {
    motorsStop();
  }
}

// ====================================================
// Ultrasonic distance measurement
// ====================================================
float measureDistanceCm()
{
  // Trigger a 10us pulse
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  // Read echo pulse width
  unsigned long duration = pulseIn(ECHO_PIN, HIGH, 30000); // timeout 30ms

  if (duration == 0) {
    // No echo
    return -1.0;
  }

  // Speed of sound ~340 m/s -> 29.1 us per cm (round trip)
  float distanceCm = (float)duration * 0.0343 / 2.0;
  return distanceCm;
}

// ====================================================
// Read direction from Firebase
// - If dir == "S" and autoStopFromObstacle == true:
//       This is auto STOP from obstacle → don't set manualStop
// - If dir == "S" and autoStopFromObstacle == false:
//       This is MANUAL stop → set manualStop = true
// - F/B/L/R:
//       Clear manualStop, autoStopFromObstacle, and store lastNonStopDirection
// ====================================================
void readDirectionFromFirebase()
{
  if (!Firebase.RTDB.getString(&fbdo, PATH_DIR)) {
    Serial.print("Failed to get direction: ");
    Serial.println(fbdo.errorReason());
    return;
  }

  String dir = fbdo.stringData();
  dir.trim();
  dir.toUpperCase();

  if (dir == "S") {
    if (autoStopFromObstacle) {
      // Auto STOP due to obstacle
      currentDirection = "S";
      // Do NOT set manualStop here
      Serial.println("[DIR] Auto STOP (from obstacle, S in Firebase)");
    } else {
      // Manual STOP from user
      manualStop = true;
      currentDirection = "S";
      Serial.println("[DIR] Manual STOP (S set by user)");
    }
  }
  else if (dir == "F" || dir == "B" || dir == "L" || dir == "R") {
    manualStop = false;
    autoStopFromObstacle = false;   // user took over control
    currentDirection = dir;
    lastNonStopDirection = dir;     // remember for resume
    Serial.print("[DIR] Command = ");
    Serial.println(dir);
  }
  else {
    Serial.print("[DIR] Invalid direction received: ");
    Serial.println(dir);
  }
}

// ====================================================
// Read Spray from Firebase and control relays
// ====================================================
void readSprayFromFirebase()
{
  if (!Firebase.RTDB.getInt(&fbdo, PATH_SPRAY)) {
    Serial.print("Failed to get Spray: ");
    Serial.println(fbdo.errorReason());
    return;
  }

  int sprayCmd = fbdo.intData();
  Serial.print("[Spray] Command = ");
  Serial.println(sprayCmd);

  // Turn all OFF first
  setRelay(RELAY1_PIN, false);
  setRelay(RELAY2_PIN, false);
  setRelay(RELAY3_PIN, false);

  if (sprayCmd == 1) {
    setRelay(RELAY1_PIN, true);
  } else if (sprayCmd == 2) {
    setRelay(RELAY2_PIN, true);
  } else if (sprayCmd == 3) {
    setRelay(RELAY3_PIN, true);
  }
}

// ====================================================
// Check obstacle via ultrasonic and update Firebase
// Behaviour:
//  - When obstacle just becomes active:
//        * obstacleActive = true
//        * Obstacle -> 1
//        * direction -> "S" (AUTO stop)
//        * autoStopFromObstacle = true
//        * motors STOP
//  - When obstacle clears:
//        * obstacleActive = false
//        * Obstacle -> 0
//        * If NOT manualStop and lastNonStopDirection != "S":
//              direction -> lastNonStopDirection (AUTO resume)
//              autoStopFromObstacle = false
// ====================================================
void checkObstacle()
{
  float dist = measureDistanceCm();
  bool previouslyActive = obstacleActive;

  if (dist > 0 && dist < OBSTACLE_THRESHOLD_CM) {
    obstacleActive = true;
  } else {
    obstacleActive = false;
  }

  if (obstacleActive != previouslyActive) {
    int obsVal = obstacleActive ? 1 : 0;

    // Update Obstacle node
    if (!Firebase.RTDB.setInt(&fbdo, PATH_OBS, obsVal)) {
      Serial.print("Failed to set Obstacle: ");
      Serial.println(fbdo.errorReason());
    }

    if (obstacleActive) {
      // Obstacle just detected:
      Serial.print("[Obstacle] DETECTED (");
      Serial.print(dist);
      Serial.println(" cm) -> auto STOP and direction=S");

      currentDirection = "S";
      autoStopFromObstacle = true;   // mark that S came from obstacle

      // Write direction=S as AUTO stop
      if (!Firebase.RTDB.setString(&fbdo, PATH_DIR, "S")) {
        Serial.print("Failed to set direction=S on obstacle: ");
        Serial.println(fbdo.errorReason());
      }
    } else {
      // Obstacle just cleared:
      Serial.print("[Obstacle] CLEARED (");
      Serial.print(dist);
      Serial.println(" cm)");

      // If user didn't manually stop and we have a last direction, resume it
      if (!manualStop && lastNonStopDirection != "S") {
        currentDirection = lastNonStopDirection;
        autoStopFromObstacle = false;  // resume normal behaviour
        Serial.print("[Obstacle] Resuming previous direction: ");
        Serial.println(lastNonStopDirection);

        if (!Firebase.RTDB.setString(&fbdo, PATH_DIR, lastNonStopDirection)) {
          Serial.print("Failed to restore direction after obstacle: ");
          Serial.println(fbdo.errorReason());
        }
      } else {
        // Either manualStop is true or we don't have a valid last direction
        autoStopFromObstacle = false;  // clear auto-stop flag anyway
        Serial.println("[Obstacle] Not resuming (manual stop or no last direction).");
      }
    }
  }

  // Ensure motors follow the latest obstacle/manual state
  updateMotors();
}

// ====================================================
// Setup
// ====================================================
void setup()
{
  Serial.begin(115200);
  delay(1000);

  // Pin modes
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);

  pinMode(RELAY1_PIN, OUTPUT);
  pinMode(RELAY2_PIN, OUTPUT);
  pinMode(RELAY3_PIN, OUTPUT);

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  // Safe initial states
  motorsStop();
  setRelay(RELAY1_PIN, false);
  setRelay(RELAY2_PIN, false);
  setRelay(RELAY3_PIN, false);

  // WiFi
  Serial.print("Connecting to WiFi: ");
  Serial.println(WIFI_SSID);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  Serial.print("WiFi connected. IP: ");
  Serial.println(WiFi.localIP());

  // Firebase config
  config.api_key = API_KEY;
  auth.user.email = USER_EMAIL;
  auth.user.password = USER_PASSWORD;
  config.database_url = DATABASE_URL;

  // Assign callback for token generation status
  config.token_status_callback = tokenStatusCallback;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);

  // Initialize RTDB values
  Firebase.RTDB.setString(&fbdo, PATH_DIR, "S");  // start in STOP
  Firebase.RTDB.setInt(&fbdo, PATH_OBS, 0);
  Firebase.RTDB.setInt(&fbdo, PATH_SPRAY, 0);

  manualStop           = true;    // start in manual stop until a direction is sent
  autoStopFromObstacle = false;
  lastNonStopDirection = "S";

  Serial.println("Setup complete. Waiting for commands...");
}

// ====================================================
// Main loop
// ====================================================
void loop()
{
  unsigned long now = millis();

  // 1) Check obstacle via ultrasonic FIRST (keep state fresh)
  if (now - lastObstacleCheckMs >= OBSTACLE_CHECK_INTERVAL_MS) {
    lastObstacleCheckMs = now;
    checkObstacle();
  }

  // 2) Periodically read direction & Spray from Firebase
  if (Firebase.ready() && (now - lastFirebaseReadMs >= FIREBASE_READ_INTERVAL_MS)) {
    lastFirebaseReadMs = now;
    readDirectionFromFirebase();
    readSprayFromFirebase();
    updateMotors();
  }

  delay(10);
}
