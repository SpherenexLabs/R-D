/************************************************************
 * ESP8266 + L293D + 4-Channel Relay + Servo + Firebase RTDB
 *
 * Firebase RTDB structure:
 *   /Pesticide/direction -> "F","B","L","R","S"
 *   /Pesticide/Relay     -> 0,1,2,3
 *   /Pesticide/Servo     -> 0,1      (auto-managed by code)
 *
 * direction commands:
 *   F -> Forward
 *   B -> Backward
 *   L -> Left  (turn on spot: left motor backward, right motor forward)
 *   R -> Right (turn on spot: left motor forward, right motor backward)
 *   S -> Stop
 *
 * Relay:
 *   0 -> all OFF
 *   1 -> Relay1 ON (others OFF)
 *   2 -> Relay2 ON (others OFF)
 *   3 -> Relay3 ON (others OFF) + SERVO 90°
 *
 * Servo rule:
 *   - Only when Relay == 3 → servo = 90°, /Pesticide/Servo = 1
 *   - All other cases      → servo = 0°,  /Pesticide/Servo = 0
 *
 * Notes:
 *   - Relays use SAFE pins: D0, D4, D7 (do NOT use D3/D8 for relays).
 *   - Servo uses D3 (GPIO0) as signal.
 *   - Auto-creates /Pesticide/direction, /Pesticide/Relay, /Pesticide/Servo if missing.
 ************************************************************/

#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <Servo.h>  // <--- NEW

#include <Firebase_ESP_Client.h>
#include "addons/TokenHelper.h"
#include "addons/RTDBHelper.h"

/// ---------------- WiFi & Firebase Config ----------------
#define WIFI_SSID      "spray"
#define WIFI_PASSWORD  "123456789"

#define API_KEY        "AIzaSyAXHnvNZkb00PXbG5JidbD4PbRgf7l6Lgg"
#define DATABASE_URL   "https://v2v-communication-d46c6-default-rtdb.firebaseio.com/"  // RTDB URL

#define USER_EMAIL     "spherenexgpt@gmail.com"
#define USER_PASSWORD  "Spherenex@123"

// Firebase objects
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// ---------------- Motor Pins (L293D) ----------------
// Same as Smart_robot
const uint8_t IN1 = D1;   // GPIO5  - Motor A Input 1
const uint8_t IN2 = D2;   // GPIO4  - Motor A Input 2
const uint8_t IN3 = D5;   // GPIO14 - Motor B Input 1
const uint8_t IN4 = D6;   // GPIO12 - Motor B Input 2

// ---------------- Relay Pins (4-Channel Board) ----------------
// Using safe pins D0, D4, D7; do NOT use D3/D8 for relays
const uint8_t RELAY1_PIN = D0;  // GPIO16 -> Relay 1 IN
const uint8_t RELAY2_PIN = D4;  // GPIO2  -> Relay 2 IN
const uint8_t RELAY3_PIN = D7;  // GPIO13 -> Relay 3 IN
// 4th channel not used – leave input unconnected

// Most 4-ch relay boards are ACTIVE LOW.
const uint8_t RELAY_ON  = LOW;
const uint8_t RELAY_OFF = HIGH;

// ---------------- Servo Pin ----------------
const uint8_t SERVO_PIN = D3;   // GPIO0 (signal only, no power from ESP)
Servo sprayServo;

// ---------------- Timing ----------------
unsigned long lastDirCheck   = 0;
unsigned long lastRelayCheck = 0;
const unsigned long DIR_INTERVAL_MS   = 300;   // check direction every 300 ms
const unsigned long RELAY_INTERVAL_MS = 300;   // check relay cmd every 300 ms

const unsigned long WIFI_CHECK_MS     = 5000;  // check WiFi every 5 seconds
unsigned long lastWifiCheck = 0;

// Cache last direction (optional, to avoid repeated prints)
String lastDirection = "";

// Forward declarations
void setupWiFi();
void setupFirebase();
void initDatabase();
void applyDirection(const String &dir);
void applyRelayCommand(int cmd);

// ---------------- Motor Control Helpers (from working Smart_robot) ----------------
void motorStop() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
}

void motorForward() {
  // Motor A forward, Motor B forward
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void motorBackward() {
  // Motor A backward, Motor B backward
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void motorLeft() {
  // Left turn: left motor backward, right motor forward
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);   // left motor backward
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);    // right motor forward
}

void motorRight() {
  // Right turn: left motor forward, right motor backward
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);    // left motor forward
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);   // right motor backward
}

void applyDirection(const String &dir) {
  if (dir == "F") {
    motorForward();
    Serial.println("Direction: FORWARD");
  } else if (dir == "B") {
    motorBackward();
    Serial.println("Direction: BACKWARD");
  } else if (dir == "L") {
    motorLeft();
    Serial.println("Direction: LEFT");
  } else if (dir == "R") {
    motorRight();
    Serial.println("Direction: RIGHT");
  } else {  // "S" or anything else
    motorStop();
    Serial.println("Direction: STOP");
  }
}

// ====================================================
// Setup
// ====================================================

void setup() {
  Serial.begin(115200);
  delay(1000);

  Serial.println();
  Serial.println("=== Pesticide Vehicle + Relay + Servo Controller ===");

  // Motor pins
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);

  motorStop();  // start stopped

  // Relay pins – set OFF before pinMode to avoid glitches
  digitalWrite(RELAY1_PIN, RELAY_OFF);
  digitalWrite(RELAY2_PIN, RELAY_OFF);
  digitalWrite(RELAY3_PIN, RELAY_OFF);

  pinMode(RELAY1_PIN, OUTPUT);
  pinMode(RELAY2_PIN, OUTPUT);
  pinMode(RELAY3_PIN, OUTPUT);

  // Ensure OFF state
  digitalWrite(RELAY1_PIN, RELAY_OFF);
  digitalWrite(RELAY2_PIN, RELAY_OFF);
  digitalWrite(RELAY3_PIN, RELAY_OFF);

  // Servo init
  sprayServo.attach(SERVO_PIN);
  sprayServo.write(0);   // start at 0°

  setupWiFi();
  setupFirebase();
  initDatabase();   // auto-create RTDB nodes if missing

  Serial.println("Setup completed.");
}

// ====================================================
// Main Loop
// ====================================================

void loop() {
  unsigned long now = millis();

  // ---------------- WiFi re-connect check ----------------
  if (now - lastWifiCheck >= WIFI_CHECK_MS) {
    lastWifiCheck = now;
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("WiFi disconnected, trying to reconnect...");
      WiFi.disconnect();
      WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    }
  }

  if (!Firebase.ready()) {
    // Wait until Firebase finishes token generation
    return;
  }

  // ---------------- Check direction in RTDB ----------------
  if (now - lastDirCheck >= DIR_INTERVAL_MS) {
    lastDirCheck = now;

    if (Firebase.RTDB.getString(&fbdo, "/Pesticide/direction")) {  // lowercase key
      String dir = fbdo.stringData();
      dir.trim();
      if (dir != lastDirection) {
        Serial.print("New direction from Firebase: ");
        Serial.println(dir);
        applyDirection(dir);
        lastDirection = dir;
      }
    } else {
      String err = fbdo.errorReason();
      // If path doesn't exist, create default
      if (err.indexOf("path not exist") != -1 || fbdo.httpCode() == 404) {
        Serial.println("direction path missing, creating default 'S'.");
        Firebase.RTDB.setString(&fbdo, "/Pesticide/direction", "S");
        applyDirection("S");
        lastDirection = "S";
      } else {
        Serial.print("Failed to read direction: ");
        Serial.println(err);
      }
    }
  }

  // ---------------- Check Relay in RTDB ----------------
  if (now - lastRelayCheck >= RELAY_INTERVAL_MS) {
    lastRelayCheck = now;

    if (Firebase.RTDB.getInt(&fbdo, "/Pesticide/Relay")) {
      int relayCmd = fbdo.intData();
      applyRelayCommand(relayCmd);
      Serial.print("Relay cmd: ");
      Serial.println(relayCmd);
    } else {
      String err = fbdo.errorReason();
      // If path doesn't exist, create default
      if (err.indexOf("path not exist") != -1 || fbdo.httpCode() == 404) {
        Serial.println("Relay path missing, creating default 0.");
        Firebase.RTDB.setInt(&fbdo, "/Pesticide/Relay", 0);
        applyRelayCommand(0);
      } else {
        Serial.print("Failed to read Relay: ");
        Serial.println(err);
      }
    }
  }
}

// ====================================================
// WiFi & Firebase Helpers
// ====================================================

void setupWiFi() {
  Serial.println();
  Serial.print("Connecting to WiFi: ");
  Serial.println(WIFI_SSID);

  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  int retries = 0;
  while (WiFi.status() != WL_CONNECTED && retries < 40) { // ~20 seconds
    delay(500);
    Serial.print(".");
    retries++;
  }

  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("WiFi connected. IP: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("WiFi connect failed, will retry in loop.");
  }
}

void setupFirebase() {
  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;

  auth.user.email    = USER_EMAIL;
  auth.user.password = USER_PASSWORD;

  // Optional: prints token generation status to Serial
  config.token_status_callback = tokenStatusCallback;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);

  Serial.println("Firebase initialized (token generation may take a few seconds).");
}

// Create default nodes if not present
void initDatabase() {
  if (!Firebase.ready()) return;

  Serial.println("Initializing Firebase nodes...");

  // direction (lowercase)
  if (!Firebase.RTDB.getString(&fbdo, "/Pesticide/direction")) {
    String err = fbdo.errorReason();
    if (err.indexOf("path not exist") != -1 || fbdo.httpCode() == 404) {
      Serial.println("Creating /Pesticide/direction = 'S'");
      Firebase.RTDB.setString(&fbdo, "/Pesticide/direction", "S");
    } else {
      Serial.print("Error checking direction: ");
      Serial.println(err);
    }
  } else {
    Serial.print("direction exists: ");
    Serial.println(fbdo.stringData());
    lastDirection = fbdo.stringData();
  }

  // Relay
  if (!Firebase.RTDB.getInt(&fbdo, "/Pesticide/Relay")) {
    String err = fbdo.errorReason();
    if (err.indexOf("path not exist") != -1 || fbdo.httpCode() == 404) {
      Serial.println("Creating /Pesticide/Relay = 0");
      Firebase.RTDB.setInt(&fbdo, "/Pesticide/Relay", 0);
    } else {
      Serial.print("Error checking Relay: ");
      Serial.println(err);
    }
  } else {
    Serial.print("Relay exists: ");
    Serial.println(fbdo.intData());
  }

  // Servo node
  if (!Firebase.RTDB.getInt(&fbdo, "/Pesticide/Servo")) {
    String err = fbdo.errorReason();
    if (err.indexOf("path not exist") != -1 || fbdo.httpCode() == 404) {
      Serial.println("Creating /Pesticide/Servo = 0");
      Firebase.RTDB.setInt(&fbdo, "/Pesticide/Servo", 0);
    } else {
      Serial.print("Error checking Servo: ");
      Serial.println(err);
    }
  } else {
    Serial.print("Servo exists: ");
    Serial.println(fbdo.intData());
  }
}

// ====================================================
// Relay + Servo Control
// ====================================================

void applyRelayCommand(int cmd) {
  // Turn all relays OFF first
  digitalWrite(RELAY1_PIN, RELAY_OFF);
  digitalWrite(RELAY2_PIN, RELAY_OFF);
  digitalWrite(RELAY3_PIN, RELAY_OFF);

  // Default servo position and Servo flag
  int servoAngle = 0;
  int servoFlag  = 0;

  switch (cmd) {
    case 1:
      digitalWrite(RELAY1_PIN, RELAY_ON);
      Serial.println("Relay1 ON");
      break;
    case 2:
      digitalWrite(RELAY2_PIN, RELAY_ON);
      Serial.println("Relay2 ON");
      break;
    case 3:
      digitalWrite(RELAY3_PIN, RELAY_ON);
      Serial.println("Relay3 ON");
      // Only when Relay == 3 → servo 90°
      servoAngle = 90;
      servoFlag  = 1;
      break;
    case 0:
    default:
      Serial.println("All relays OFF");
      break;
  }

  // Apply servo position
  sprayServo.write(servoAngle);

  // Update /Pesticide/Servo in RTDB (0 or 1)
  if (Firebase.ready()) {
    if (!Firebase.RTDB.setInt(&fbdo, "/Pesticide/Servo", servoFlag)) {
      Serial.print("Failed to update /Pesticide/Servo: ");
      Serial.println(fbdo.errorReason());
    } else {
      Serial.print("Servo node updated: ");
      Serial.println(servoFlag);
    }
  }
}
