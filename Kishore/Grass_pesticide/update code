/************************************************************
 * ESP8266 + L293D + 4-Channel Relay + Servo + Ultrasonic + Firebase RTDB
 *
 * Firebase RTDB structure:
 *   /Pesticide/direction -> "F","B","L","R","S"
 *   /Pesticide/Relay     -> 0,1,2,3
 *   /Pesticide/Servo     -> 0,1      (auto-managed by code)
 *   /Pesticide/Obstcale  -> 0,1      (0 = no obstacle, 1 = obstacle)
 *
 * direction commands:
 *   F -> Forward
 *   B -> Backward
 *   L -> Left  (turn on spot: left motor backward, right motor forward)
 *   R -> Right (turn on spot: left motor forward, right motor backward)
 *   S -> Stop
 *
 * Relay:
 *   0 -> all OFF
 *   1 -> Relay1 ON (others OFF)
 *   2 -> Relay2 ON (others OFF)
 *   3 -> Relay3 ON (others OFF) + SERVO 90°
 *
 * Servo rule:
 *   - Only when Relay == 3 → servo = 90°, /Pesticide/Servo = 1
 *   - All other cases      → servo = 0°,  /Pesticide/Servo = 0
 *
 * Ultrasonic rule:
 *   - If distance <= OBSTACLE_THRESHOLD_CM  → obstacle detected:
 *       * /Pesticide/Obstcale = 1
 *       * Motors STOP (direction on motors overridden to "S")
 *       * Firebase /Pesticide/direction is NOT changed
 *   - Else (no obstacle):
 *       * /Pesticide/Obstcale = 0
 *       * Motors run according to last direction received from Firebase
 *         (but only if Firebase direction != "S")
 *
 * Notes:
 *   - Relays use SAFE pins: D0, D4, D7 (do NOT use D3/D8 for relays).
 *   - Servo uses D3 (GPIO0) as signal.
 *   - Ultrasonic TRIG uses D8 (GPIO15).
 *   - Ultrasonic ECHO uses RX pin (GPIO3) – see wiring notes.
 ************************************************************/

#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <Servo.h>

#include <Firebase_ESP_Client.h>
#include "addons/TokenHelper.h"
#include "addons/RTDBHelper.h"

/// ---------------- WiFi & Firebase Config ----------------
#define WIFI_SSID      "spray"
#define WIFI_PASSWORD  "123456789"

#define API_KEY        "AIzaSyAXHnvNZkb00PXbG5JidbD4PbRgf7l6Lgg"
#define DATABASE_URL   "https://v2v-communication-d46c6-default-rtdb.firebaseio.com/"

#define USER_EMAIL     "spherenexgpt@gmail.com"
#define USER_PASSWORD  "Spherenex@123"

// Firebase objects
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// ---------------- Motor Pins (L293D) ----------------
const uint8_t IN1 = D1;   // GPIO5  - Motor A Input 1
const uint8_t IN2 = D2;   // GPIO4  - Motor A Input 2
const uint8_t IN3 = D5;   // GPIO14 - Motor B Input 1
const uint8_t IN4 = D6;   // GPIO12 - Motor B Input 2

// ---------------- Relay Pins (4-Channel Board) ----------------
// Using safe pins D0, D4, D7; do NOT use D3/D8 for relays
const uint8_t RELAY1_PIN = D0;  // GPIO16 -> Relay 1 IN
const uint8_t RELAY2_PIN = D4;  // GPIO2  -> Relay 2 IN
const uint8_t RELAY3_PIN = D7;  // GPIO13 -> Relay 3 IN
// 4th channel not used – leave input unconnected

// Most 4-ch relay boards are ACTIVE LOW.
const uint8_t RELAY_ON  = LOW;
const uint8_t RELAY_OFF = HIGH;

// ---------------- Servo Pin ----------------
const uint8_t SERVO_PIN = D3;   // GPIO0 (signal only, no power from ESP)
Servo sprayServo;

// ---------------- Ultrasonic Sensor Pins ----------------
// HC-SR04 or similar
const uint8_t ULTRASONIC_TRIG = D8;  // GPIO15
// Using RX pin (GPIO3) as ECHO input:
const uint8_t ULTRASONIC_ECHO = 3;   // GPIO3 (RX pin on NodeMCU)
const float OBSTACLE_THRESHOLD_CM = 20.0;  // distance threshold

// ---------------- Timing ----------------
unsigned long lastDirCheck      = 0;
unsigned long lastRelayCheck    = 0;
unsigned long lastUltraCheck    = 0;
unsigned long lastWifiCheck     = 0;

const unsigned long DIR_INTERVAL_MS     = 300;   // check direction every 300 ms
const unsigned long RELAY_INTERVAL_MS   = 300;   // check relay cmd every 300 ms
const unsigned long ULTRA_INTERVAL_MS   = 200;   // check ultrasonic every 200 ms
const unsigned long WIFI_CHECK_MS       = 5000;  // check WiFi every 5 seconds

// Direction state
String firebaseDirection  = "S";  // Last direction command from Firebase
String effectiveDirection = "S";  // Direction actually applied to motors

// Obstacle state
bool obstaclePresent      = false;

// RTDB paths
const char* PATH_DIRECTION = "/Pesticide/direction";
const char* PATH_RELAY     = "/Pesticide/Relay";
const char* PATH_SERVO     = "/Pesticide/Servo";
const char* PATH_OBSTCALE  = "/Pesticide/Obstcale";   // spelled as requested

// Forward declarations
void setupWiFi();
void setupFirebase();
void initDatabase();
void applyDirection(const String &dir);
void applyRelayCommand(int cmd);
float readUltrasonicDistanceCm();
void handleObstacleLogic();

// ---------------- Motor Control Helpers ----------------
void motorStop() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
}

void motorForward() {
  // Motor A forward, Motor B forward
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void motorBackward() {
  // Motor A backward, Motor B backward
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void motorLeft() {
  // Left turn: left motor backward, right motor forward
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);   // left motor backward
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);    // right motor forward
}

void motorRight() {
  // Right turn: left motor forward, right motor backward
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);    // left motor forward
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);   // right motor backward
}

void applyDirection(const String &dir) {
  if (dir == "F") {
    motorForward();
    Serial.println("Direction: FORWARD");
  } else if (dir == "B") {
    motorBackward();
    Serial.println("Direction: BACKWARD");
  } else if (dir == "L") {
    motorLeft();
    Serial.println("Direction: LEFT");
  } else if (dir == "R") {
    motorRight();
    Serial.println("Direction: RIGHT");
  } else {  // "S" or anything else
    motorStop();
    Serial.println("Direction: STOP");
  }
}

// ====================================================
// Setup
// ====================================================

void setup() {
  Serial.begin(115200);
  delay(1000);

  Serial.println();
  Serial.println("=== Pesticide Vehicle + Relay + Servo + Ultrasonic Controller ===");

  // Motor pins
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);

  motorStop();  // start stopped

  // Relay pins – set OFF before pinMode to avoid glitches
  digitalWrite(RELAY1_PIN, RELAY_OFF);
  digitalWrite(RELAY2_PIN, RELAY_OFF);
  digitalWrite(RELAY3_PIN, RELAY_OFF);

  pinMode(RELAY1_PIN, OUTPUT);
  pinMode(RELAY2_PIN, OUTPUT);
  pinMode(RELAY3_PIN, OUTPUT);

  // Ensure OFF state
  digitalWrite(RELAY1_PIN, RELAY_OFF);
  digitalWrite(RELAY2_PIN, RELAY_OFF);
  digitalWrite(RELAY3_PIN, RELAY_OFF);

  // Servo init
  sprayServo.attach(SERVO_PIN);
  sprayServo.write(0);   // start at 0°

  // Ultrasonic pins
  pinMode(ULTRASONIC_TRIG, OUTPUT);
  pinMode(ULTRASONIC_ECHO, INPUT);
  digitalWrite(ULTRASONIC_TRIG, LOW);

  setupWiFi();
  setupFirebase();
  initDatabase();   // auto-create RTDB nodes if missing

  Serial.println("Setup completed.");
}

// ====================================================
// Main Loop
// ====================================================

void loop() {
  unsigned long now = millis();

  // ---------------- WiFi re-connect check ----------------
  if (now - lastWifiCheck >= WIFI_CHECK_MS) {
    lastWifiCheck = now;
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("WiFi disconnected, trying to reconnect...");
      WiFi.disconnect();
      WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    }
  }

  if (!Firebase.ready()) {
    // Wait until Firebase finishes token generation
    return;
  }

  // ---------------- Ultrasonic / Obstacle check ----------------
  if (now - lastUltraCheck >= ULTRA_INTERVAL_MS) {
    lastUltraCheck = now;
    handleObstacleLogic();
  }

  // ---------------- Check direction in RTDB ----------------
  if (now - lastDirCheck >= DIR_INTERVAL_MS) {
    lastDirCheck = now;

    if (Firebase.RTDB.getString(&fbdo, PATH_DIRECTION)) {  // lowercase key
      String dir = fbdo.stringData();
      dir.trim();

      if (dir != firebaseDirection) {
        Serial.print("New direction from Firebase: ");
        Serial.println(dir);
        firebaseDirection = dir;

        // Only apply this direction if no obstacle is present
        if (!obstaclePresent && firebaseDirection != effectiveDirection) {
          applyDirection(firebaseDirection);
          effectiveDirection = firebaseDirection;
        }
      }
    } else {
      String err = fbdo.errorReason();
      // If path doesn't exist, create default
      if (err.indexOf("path not exist") != -1 || fbdo.httpCode() == 404) {
        Serial.println("direction path missing, creating default 'S'.");
        Firebase.RTDB.setString(&fbdo, PATH_DIRECTION, "S");
        firebaseDirection  = "S";
        if (!obstaclePresent) {
          applyDirection("S");
          effectiveDirection = "S";
        }
      } else {
        Serial.print("Failed to read direction: ");
        Serial.println(err);
      }
    }
  }

  // ---------------- Check Relay in RTDB ----------------
  if (now - lastRelayCheck >= RELAY_INTERVAL_MS) {
    lastRelayCheck = now;

    if (Firebase.RTDB.getInt(&fbdo, PATH_RELAY)) {
      int relayCmd = fbdo.intData();
      applyRelayCommand(relayCmd);
      Serial.print("Relay cmd: ");
      Serial.println(relayCmd);
    } else {
      String err = fbdo.errorReason();
      // If path doesn't exist, create default
      if (err.indexOf("path not exist") != -1 || fbdo.httpCode() == 404) {
        Serial.println("Relay path missing, creating default 0.");
        Firebase.RTDB.setInt(&fbdo, PATH_RELAY, 0);
        applyRelayCommand(0);
      } else {
        Serial.print("Failed to read Relay: ");
        Serial.println(err);
      }
    }
  }
}

// ====================================================
// WiFi & Firebase Helpers
// ====================================================

void setupWiFi() {
  Serial.println();
  Serial.print("Connecting to WiFi: ");
  Serial.println(WIFI_SSID);

  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  int retries = 0;
  while (WiFi.status() != WL_CONNECTED && retries < 40) { // ~20 seconds
    delay(500);
    Serial.print(".");
    retries++;
  }

  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("WiFi connected. IP: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("WiFi connect failed, will retry in loop.");
  }
}

void setupFirebase() {
  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;

  auth.user.email    = USER_EMAIL;
  auth.user.password = USER_PASSWORD;

  // Optional: prints token generation status to Serial
  config.token_status_callback = tokenStatusCallback;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);

  Serial.println("Firebase initialized (token generation may take a few seconds).");
}

// Create default nodes if not present
void initDatabase() {
  if (!Firebase.ready()) return;

  Serial.println("Initializing Firebase nodes...");

  // direction (lowercase)
  if (!Firebase.RTDB.getString(&fbdo, PATH_DIRECTION)) {
    String err = fbdo.errorReason();
    if (err.indexOf("path not exist") != -1 || fbdo.httpCode() == 404) {
      Serial.println("Creating /Pesticide/direction = 'S'");
      Firebase.RTDB.setString(&fbdo, PATH_DIRECTION, "S");
      firebaseDirection = "S";
    } else {
      Serial.print("Error checking direction: ");
      Serial.println(err);
    }
  } else {
    firebaseDirection = fbdo.stringData();
    Serial.print("direction exists: ");
    Serial.println(firebaseDirection);
  }

  // Relay
  if (!Firebase.RTDB.getInt(&fbdo, PATH_RELAY)) {
    String err = fbdo.errorReason();
    if (err.indexOf("path not exist") != -1 || fbdo.httpCode() == 404) {
      Serial.println("Creating /Pesticide/Relay = 0");
      Firebase.RTDB.setInt(&fbdo, PATH_RELAY, 0);
    } else {
      Serial.print("Error checking Relay: ");
      Serial.println(err);
    }
  } else {
    Serial.print("Relay exists: ");
    Serial.println(fbdo.intData());
  }

  // Servo node
  if (!Firebase.RTDB.getInt(&fbdo, PATH_SERVO)) {
    String err = fbdo.errorReason();
    if (err.indexOf("path not exist") != -1 || fbdo.httpCode() == 404) {
      Serial.println("Creating /Pesticide/Servo = 0");
      Firebase.RTDB.setInt(&fbdo, PATH_SERVO, 0);
    } else {
      Serial.print("Error checking Servo: ");
      Serial.println(err);
    }
  } else {
    Serial.print("Servo exists: ");
    Serial.println(fbdo.intData());
  }

  // Obstcale node
  if (!Firebase.RTDB.getInt(&fbdo, PATH_OBSTCALE)) {
    String err = fbdo.errorReason();
    if (err.indexOf("path not exist") != -1 || fbdo.httpCode() == 404) {
      Serial.println("Creating /Pesticide/Obstcale = 0");
      Firebase.RTDB.setInt(&fbdo, PATH_OBSTCALE, 0);
    } else {
      Serial.print("Error checking Obstcale: ");
      Serial.println(err);
    }
  } else {
    Serial.print("Obstcale exists: ");
    Serial.println(fbdo.intData());
  }

  // Start with motors stopped
  effectiveDirection = "S";
  applyDirection("S");
}

// ====================================================
// Relay + Servo Control
// ====================================================

void applyRelayCommand(int cmd) {
  // Turn all relays OFF first
  digitalWrite(RELAY1_PIN, RELAY_OFF);
  digitalWrite(RELAY2_PIN, RELAY_OFF);
  digitalWrite(RELAY3_PIN, RELAY_OFF);

  // Default servo position and Servo flag
  int servoAngle = 0;
  int servoFlag  = 0;

  switch (cmd) {
    case 1:
      digitalWrite(RELAY1_PIN, RELAY_ON);
      Serial.println("Relay1 ON");
      break;
    case 2:
      digitalWrite(RELAY2_PIN, RELAY_ON);
      Serial.println("Relay2 ON");
      break;
    case 3:
      digitalWrite(RELAY3_PIN, RELAY_ON);
      Serial.println("Relay3 ON");
      // Only when Relay == 3 → servo 90°
      servoAngle = 90;
      servoFlag  = 1;
      break;
    case 0:
    default:
      Serial.println("All relays OFF");
      break;
  }

  // Apply servo position
  sprayServo.write(servoAngle);

  // Update /Pesticide/Servo in RTDB (0 or 1)
  if (Firebase.ready()) {
    if (!Firebase.RTDB.setInt(&fbdo, PATH_SERVO, servoFlag)) {
      Serial.print("Failed to update /Pesticide/Servo: ");
      Serial.println(fbdo.errorReason());
    } else {
      Serial.print("Servo node updated: ");
      Serial.println(servoFlag);
    }
  }
}

// ====================================================
// Ultrasonic + Obstacle logic
// ====================================================

float readUltrasonicDistanceCm() {
  // Send 10us pulse on TRIG and measure ECHO pulse width
  digitalWrite(ULTRASONIC_TRIG, LOW);
  delayMicroseconds(2);
  digitalWrite(ULTRASONIC_TRIG, HIGH);
  delayMicroseconds(10);
  digitalWrite(ULTRASONIC_TRIG, LOW);

  unsigned long duration = pulseIn(ULTRASONIC_ECHO, HIGH, 30000); // timeout 30 ms (~5m)

  if (duration == 0) {
    // No echo detected
    return -1.0;
  }

  float distance = duration / 58.0;  // approximate conversion to cm
  return distance;
}

void handleObstacleLogic() {
  float distance = readUltrasonicDistanceCm();

  bool newObstacleState = false;

  if (distance > 0 && distance <= OBSTACLE_THRESHOLD_CM) {
    newObstacleState = true;
  } else {
    newObstacleState = false;
  }

  if (newObstacleState != obstaclePresent) {
    // State changed
    obstaclePresent = newObstacleState;

    if (obstaclePresent) {
      Serial.print("Obstacle detected at distance (cm): ");
      Serial.println(distance);

      // Stop motors and override direction on motors only
      if (effectiveDirection != "S") {
        applyDirection("S");
        effectiveDirection = "S";
      }

      // Update RTDB: Obstcale = 1 (do NOT touch direction here)
      if (Firebase.ready()) {
        if (!Firebase.RTDB.setInt(&fbdo, PATH_OBSTCALE, 1)) {
          Serial.print("Failed to update Obstcale=1: ");
          Serial.println(fbdo.errorReason());
        }
      }

    } else {
      Serial.print("Obstacle cleared. Last distance (cm): ");
      Serial.println(distance);

      // Update RTDB: Obstcale = 0
      if (Firebase.ready()) {
        if (!Firebase.RTDB.setInt(&fbdo, PATH_OBSTCALE, 0)) {
          Serial.print("Failed to update Obstcale=0: ");
          Serial.println(fbdo.errorReason());
        }
      }

      // Resume previous direction from Firebase ONLY if it is not "S"
      if (!obstaclePresent && firebaseDirection != "S" && firebaseDirection != effectiveDirection) {
        Serial.print("Resuming direction: ");
        Serial.println(firebaseDirection);
        applyDirection(firebaseDirection);
        effectiveDirection = firebaseDirection;
      } else {
        Serial.println("Not resuming motion (firebaseDirection is 'S' or same as effectiveDirection).");
      }
    }
  }
  // If state didn't change, we do nothing extra to avoid too many RTDB writes
}
