#include <WiFi.h>
#include <Wire.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <DHT.h>

#include <Firebase_ESP_Client.h>
#include "addons/TokenHelper.h"
#include "addons/RTDBHelper.h"

// ===================== WiFi =====================
#define WIFI_SSID     "engine"
#define WIFI_PASSWORD "123456789"

// ===================== Firebase =====================
#define API_KEY       "AIzaSyAXHnvNZkb00PXbG5JidbD4PbRgf7l6Lgg"
#define DATABASE_URL  "https://v2v-communication-d46c6-default-rtdb.firebaseio.com/"
#define USER_EMAIL    "spherenexgpt@gmail.com"
#define USER_PASSWORD "Spherenex@123"

// ===================== Pins =====================
#define I2C_SDA 21
#define I2C_SCL 22

#define DHTPIN  16
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// ADC1 pins
#define PIN_VOLT  34
#define PIN_WATER 35
#define PIN_OIL   32
#define PIN_FUEL  33

// ===================== ADC =====================
static const float ADC_MAX_COUNTS = 4095.0f;
static const float ADC_REF_V      = 3.3f;

// ✅ For common "0-25V" sensor module (made for 5V ADC): divider is typically 5:1 (Vin -> Vout = Vin/5)
static const float VOLT_DIV_RATIO = 5.0f;

// Optional fine calibration
// If multimeter differs: VOLT_CAL = real / measured
static float VOLT_CAL = 1.00f;

// 2S pack max
static const float VPACK_MAX = 8.40f;
static const float VPACK_MIN = 0.00f;

// Battery% smoothing
static const float BAT_EMA_ALPHA = 0.20f;

// ===================== Level sensor tuning =====================
static const int   LEVEL_WET_THRESHOLD = 5;
static const float EMA_ALPHA = 0.20f;

static int waterMaxLearn = 60;
static int oilMaxLearn   = 60;
static int fuelMaxLearn  = 60;
static const int MAX_LEARN_CAP = 200;

// ===================== Timers =====================
static const uint32_t READ_MPU_MS   = 200;
static const uint32_t READ_ADC_MS   = 250;
static const uint32_t READ_DHT_MS   = 2000;
static const uint32_t UPLOAD_MS     = 1200;

// ===================== Firebase =====================
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// ===================== Sensors =====================
Adafruit_MPU6050 mpu;
bool mpuOk = false;

// Firebase base node
const String BASE = "/Engine_Health";

// Cached values
float ax=0, ay=0, az=0;

float tempC = -127.0f;
float humP  = -1.0f;      // ✅ Humidity (%)

float battV = 0;          // clamped 0..8.4
float battPct = 0;        // 0..100

float waterPct = 0, oilPct = 0, fuelPct = 0;

// ---------- Helpers ----------
static float clampf(float x, float lo, float hi) {
  if (x < lo) return lo;
  if (x > hi) return hi;
  return x;
}

static float ema(float prev, float curr, float alpha) {
  return alpha * curr + (1.0f - alpha) * prev;
}

static int readADCavg(int pin) {
  long sum = 0;
  const int N = 8;
  for (int i = 0; i < N; i++) {
    sum += analogRead(pin);
    delay(2);
  }
  return (int)(sum / N);
}

static float adcToVolts(int adc) {
  return ((float)adc / ADC_MAX_COUNTS) * ADC_REF_V;
}

// ADC -> pack voltage using divider ratio
static float estimateBatteryVoltage(int adc) {
  float vOut = adcToVolts(adc);              // ADC pin voltage 0..3.3V
  float vIn  = vOut * VOLT_DIV_RATIO;        // divider conversion
  return vIn * VOLT_CAL;                     // calibration
}

// Battery% from 0..8.4V
static float voltageToBatteryPct_0to8p4(float vPackClamped) {
  float t = vPackClamped / VPACK_MAX;
  t = clampf(t, 0.0f, 1.0f);
  return t * 100.0f;
}

// Convert raw touch sensor to %
static float levelToPercent(int raw, int &maxLearn) {
  raw = (raw < 0) ? 0 : raw;

  if (raw <= LEVEL_WET_THRESHOLD) return 0.0f;

  if (raw > maxLearn) {
    maxLearn = raw;
    if (maxLearn > MAX_LEARN_CAP) maxLearn = MAX_LEARN_CAP;
  }

  int effectiveMax = maxLearn;
  if (effectiveMax < 30) effectiveMax = 30;

  float t = (float)(raw - LEVEL_WET_THRESHOLD) / (float)(effectiveMax - LEVEL_WET_THRESHOLD);
  t = clampf(t, 0.0f, 1.0f);
  return t * 100.0f;
}

// ---------- WiFi ----------
static void connectWiFi() {
  Serial.println();
  Serial.println("ESP32 WiFi Connect");

  WiFi.mode(WIFI_STA);
  WiFi.setSleep(false);
  WiFi.persistent(false);
  WiFi.setAutoReconnect(true);

  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  uint32_t start = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
    if (millis() - start > 25000) {
      Serial.println("\nRetry WiFi...");
      WiFi.disconnect(false);
      delay(1000);
      WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
      start = millis();
    }
  }

  Serial.println("\nWIFI CONNECTED");
  Serial.print("IP: "); Serial.println(WiFi.localIP());
}

// ---------- Firebase ----------
static void initFirebase() {
  Serial.println("Firebase Init...");

  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;

  auth.user.email = USER_EMAIL;
  auth.user.password = USER_PASSWORD;

  config.token_status_callback = tokenStatusCallback;

  Firebase.reconnectWiFi(true);
  fbdo.setResponseSize(4096);
  fbdo.setBSSLBufferSize(4096, 1024);

  Firebase.begin(&config, &auth);
  Serial.println("Firebase.begin done");
}

static bool waitFirebaseReady(uint32_t timeoutMs = 25000) {
  Serial.println("Waiting Firebase token...");
  uint32_t start = millis();
  while (!Firebase.ready()) {
    delay(250);
    if (millis() - start > timeoutMs) {
      Serial.print("Firebase token timeout. Reason: ");
      Serial.println(fbdo.errorReason());
      return false;
    }
  }
  Serial.println("Firebase READY OK");
  return true;
}

// ✅ Upload existing nodes + NEW Hum node
static void uploadAllOnce() {
  if (!Firebase.ready()) return;

  FirebaseJson json;

  json.set("MPU/X", ax);
  json.set("MPU/Y", ay);
  json.set("MPU/Z", az);

  json.set("Fuel", fuelPct);
  json.set("Oil", oilPct);
  json.set("Water", waterPct);

  json.set("Temp", tempC);
  json.set("Hum",  humP);       // ✅ NEW NODE: Hum

  json.set("Volt", battV);
  json.set("Battery", battPct);

  if (!Firebase.RTDB.updateNode(&fbdo, BASE.c_str(), &json)) {
    Serial.print("Firebase update FAIL | reason: ");
    Serial.print(fbdo.errorReason());
    Serial.print(" | http: ");
    Serial.println(fbdo.httpCode());
  } else {
    Serial.println("Firebase updated OK");
  }
}

void setup() {
  Serial.begin(115200);
  delay(500);

  // ADC setup
  analogReadResolution(12);
  analogSetPinAttenuation(PIN_VOLT,  ADC_11db);
  analogSetPinAttenuation(PIN_WATER, ADC_11db);
  analogSetPinAttenuation(PIN_OIL,   ADC_11db);
  analogSetPinAttenuation(PIN_FUEL,  ADC_11db);

  connectWiFi();
  initFirebase();
  waitFirebaseReady();

  // Sensors
  Wire.begin(I2C_SDA, I2C_SCL);
  Wire.setClock(100000);
  dht.begin();

  Serial.println("MPU6050 init...");
  mpuOk = mpu.begin();
  if (!mpuOk) Serial.println("WARNING: MPU6050 not found.");
  else Serial.println("MPU6050 OK");

  Serial.println("OK: Engine Health Logger Started (ESP32)");

  Serial.print("VOLT_DIV_RATIO: "); Serial.println(VOLT_DIV_RATIO, 2);
  Serial.print("VOLT_CAL: "); Serial.println(VOLT_CAL, 4);
}

void loop() {
  static uint32_t tMpu = 0, tAdc = 0, tDht = 0, tUp = 0;

  if (WiFi.status() != WL_CONNECTED) connectWiFi();

  uint32_t now = millis();

  // MPU
  if (now - tMpu >= READ_MPU_MS) {
    tMpu = now;
    if (mpuOk) {
      sensors_event_t a, g, tt;
      mpu.getEvent(&a, &g, &tt);
      ax = a.acceleration.x;
      ay = a.acceleration.y;
      az = a.acceleration.z;
    } else {
      ax = ay = az = 0;
    }
  }

  // ADC sensors
  if (now - tAdc >= READ_ADC_MS) {
    tAdc = now;

    int adcVolt  = readADCavg(PIN_VOLT);
    int rawWater = readADCavg(PIN_WATER);
    int rawOil   = readADCavg(PIN_OIL);
    int rawFuel  = readADCavg(PIN_FUEL);

    float vRaw = estimateBatteryVoltage(adcVolt);

    battV = clampf(vRaw, VPACK_MIN, VPACK_MAX);

    float bpNow = voltageToBatteryPct_0to8p4(battV);
    battPct = clampf(ema(battPct, bpNow, BAT_EMA_ALPHA), 0.0f, 100.0f);

    float w = levelToPercent(rawWater, waterMaxLearn);
    float o = levelToPercent(rawOil,   oilMaxLearn);
    float f = levelToPercent(rawFuel,  fuelMaxLearn);

    waterPct = clampf(ema(waterPct, w, EMA_ALPHA), 0.0f, 100.0f);
    oilPct   = clampf(ema(oilPct,   o, EMA_ALPHA), 0.0f, 100.0f);
    fuelPct  = clampf(ema(fuelPct,  f, EMA_ALPHA), 0.0f, 100.0f);

    Serial.print("Volt(V): "); Serial.print(battV, 3);
    Serial.print(" | Battery(%): "); Serial.println(battPct, 1);
  }

  // DHT (Temp + Hum)
  if (now - tDht >= READ_DHT_MS) {
    tDht = now;

    float t = dht.readTemperature();
    float h = dht.readHumidity();

    if (!isnan(t)) tempC = t;
    if (!isnan(h)) humP  = h;
  }

  // Upload
  if (now - tUp >= UPLOAD_MS) {
    tUp = now;
    uploadAllOnce();
  }
}
