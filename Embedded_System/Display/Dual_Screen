/*
 * Dual OLED Display Controller
 * 
 * This code manages two SSD1306 OLED displays through a PCA9548A I2C multiplexer.
 * Display 1 (Channel 0): Shows health monitoring data (Heart Rate & SpO2)
 * Display 2 (Channel 1): Shows MPU6050 motion sensor data (angles & acceleration)
 * 
 * Hardware Requirements:
 * - 2x SSD1306 OLED displays (128x64)
 * - 1x PCA9548A I2C multiplexer
 * - ESP8266/ESP32 or Arduino compatible board
 * 
 * Connections:
 * - ESP8266: SDA=GPIO4 (D2), SCL=GPIO5 (D1)
 * - Arduino Uno: SDA=A4, SCL=A5
 * - Both OLEDs connect to multiplexer outputs
 * - Multiplexer connects to main I2C bus
 */

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// Hardware Configuration
#define MUX_I2C_ADDR        0x70    // PCA9548A multiplexer I2C address
#define OLED_I2C_ADDR       0x3C    // SSD1306 OLED I2C address
#define SCREEN_WIDTH        128     // OLED display width in pixels
#define SCREEN_HEIGHT       64      // OLED display height in pixels
#define OLED_RESET_PIN      -1      // Reset pin (or -1 if sharing Arduino reset pin)

// Multiplexer Channels
#define HEALTH_DISPLAY_CHANNEL  0   // Channel for health monitoring display
#define MOTION_DISPLAY_CHANNEL  1   // Channel for motion sensor display

// Display Objects
Adafruit_SSD1306 healthDisplay(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET_PIN);
Adafruit_SSD1306 motionDisplay(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET_PIN);

// Data Storage
struct HealthData {
  uint16_t heartRate;
  uint8_t spO2;
  bool isConnected;
};

struct MotionData {
  float angleX, angleY, angleZ;
  float accelX, accelY, accelZ;
  float gyroX, gyroY, gyroZ;
  bool isConnected;
};

HealthData healthData = {0, 0, false};
MotionData motionData = {0, 0, 0, 0, 0, 0, 0, 0, 0, false};

// Timing Variables
unsigned long lastUpdate = 0;
unsigned long lastDataSimulation = 0;
const unsigned long UPDATE_INTERVAL = 500;     // Update displays every 500ms
const unsigned long DATA_INTERVAL = 100;       // Simulate new data every 100ms

/**
 * Select I2C multiplexer channel
 * @param channel Channel number (0-7)
 */
void selectMuxChannel(uint8_t channel) {
  if (channel > 7) {
    Serial.println("Error: Invalid multiplexer channel");
    return;
  }
  
  Wire.beginTransmission(MUX_I2C_ADDR);
  Wire.write(1 << channel);
  uint8_t error = Wire.endTransmission();
  
  if (error != 0) {
    Serial.print("Multiplexer error on channel ");
    Serial.print(channel);
    Serial.print(": ");
    Serial.println(error);
  }
}

/**
 * Initialize OLED display on specific multiplexer channel
 * @param display Reference to display object
 * @param channel Multiplexer channel
 * @param name Display name for debugging
 * @return true if successful, false otherwise
 */
bool initializeDisplay(Adafruit_SSD1306 &display, uint8_t channel, const char* name) {
  selectMuxChannel(channel);
  delay(10); // Small delay for channel switching
  
  if (!display.begin(SSD1306_SWITCHCAPVCC, OLED_I2C_ADDR)) {
    Serial.print("Failed to initialize ");
    Serial.println(name);
    return false;
  }
  
  // Clear display and show initialization message
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.print("Initializing...");
  display.setCursor(0, 10);
  display.print(name);
  display.display();
  
  Serial.print(name);
  Serial.println(" initialized successfully");
  return true;
}

/**
 * Draw health monitoring screen
 */
void updateHealthDisplay() {
  selectMuxChannel(HEALTH_DISPLAY_CHANNEL);
  
  healthDisplay.clearDisplay();
  
  // Title
  healthDisplay.setTextSize(2);
  healthDisplay.setTextColor(SSD1306_WHITE);
  healthDisplay.setCursor(0, 0);
  healthDisplay.print("HEALTH");
  
  // Connection status indicator
  healthDisplay.setTextSize(1);
  healthDisplay.setCursor(100, 5);
  if (healthData.isConnected) {
    healthDisplay.print("CONN");
  } else {
    healthDisplay.print("DISC");
  }
  
  // Separator line
  healthDisplay.drawLine(0, 18, SCREEN_WIDTH - 1, 18, SSD1306_WHITE);
  
  // Heart Rate Section
  healthDisplay.setCursor(0, 24);
  healthDisplay.setTextSize(1);
  healthDisplay.print("Heart Rate:");
  
  healthDisplay.setCursor(0, 35);
  healthDisplay.setTextSize(2);
  if (healthData.isConnected) {
    healthDisplay.print(healthData.heartRate);
    healthDisplay.setTextSize(1);
    healthDisplay.print(" BPM");
  } else {
    healthDisplay.setTextSize(1);
    healthDisplay.print("No Signal");
  }
  
  // SpO2 Section
  healthDisplay.setCursor(0, 50);
  healthDisplay.setTextSize(1);
  healthDisplay.print("SpO2: ");
  
  if (healthData.isConnected) {
    healthDisplay.setTextSize(1);
    healthDisplay.print(healthData.spO2);
    healthDisplay.print(" %");
    
    // Simple pulse indicator (heart icon simulation)
    if (millis() % 1000 < 100) { // Blink every second
      healthDisplay.fillCircle(110, 53, 3, SSD1306_WHITE);
    }
  } else {
    healthDisplay.print("--");
  }
  
  healthDisplay.display();
}

/**
 * Draw motion sensor screen
 */
void updateMotionDisplay() {
  selectMuxChannel(MOTION_DISPLAY_CHANNEL);
  
  motionDisplay.clearDisplay();
  
  // Title and status
  motionDisplay.setTextSize(1);
  motionDisplay.setTextColor(SSD1306_WHITE);
  motionDisplay.setCursor(0, 0);
  motionDisplay.print("MPU6050");
  
  motionDisplay.setCursor(100, 0);
  if (motionData.isConnected) {
    motionDisplay.print("OK");
  } else {
    motionDisplay.print("ERR");
  }
  
  // Separator
  motionDisplay.drawLine(0, 10, SCREEN_WIDTH - 1, 10, SSD1306_WHITE);
  
  if (motionData.isConnected) {
    // Orientation (Angles)
    motionDisplay.setCursor(0, 14);
    motionDisplay.print("Orientation:");
    
    motionDisplay.setCursor(0, 24);
    motionDisplay.print("X:");
    motionDisplay.print(motionData.angleX, 1);
    motionDisplay.print((char)247); // Degree symbol
    
    motionDisplay.setCursor(65, 24);
    motionDisplay.print("Y:");
    motionDisplay.print(motionData.angleY, 1);
    motionDisplay.print((char)247);
    
    motionDisplay.setCursor(0, 34);
    motionDisplay.print("Z:");
    motionDisplay.print(motionData.angleZ, 1);
    motionDisplay.print((char)247);
    
    // Acceleration
    motionDisplay.setCursor(0, 46);
    motionDisplay.print("Accel (g):");
    
    motionDisplay.setCursor(0, 56);
    motionDisplay.print("X:");
    motionDisplay.print(motionData.accelX, 2);
    
    motionDisplay.setCursor(42, 56);
    motionDisplay.print("Y:");
    motionDisplay.print(motionData.accelY, 2);
    
    motionDisplay.setCursor(84, 56);
    motionDisplay.print("Z:");
    motionDisplay.print(motionData.accelZ, 2);
    
  } else {
    motionDisplay.setCursor(0, 25);
    motionDisplay.setTextSize(2);
    motionDisplay.print("NO SENSOR");
    motionDisplay.setTextSize(1);
    motionDisplay.setCursor(0, 45);
    motionDisplay.print("Check connection");
  }
  
  motionDisplay.display();
}

/**
 * Simulate sensor data for demonstration
 * In real application, replace with actual sensor readings
 */
void simulateSensorData() {
  static float time = 0;
  time += 0.1;
  
  // Simulate health data
  healthData.isConnected = true;
  healthData.heartRate = 72 + (int)(sin(time * 0.5) * 8); // Varying heart rate
  healthData.spO2 = 98 + (int)(sin(time * 0.3) * 2);      // Varying SpO2
  
  // Simulate motion data
  motionData.isConnected = true;
  motionData.angleX = sin(time) * 30;
  motionData.angleY = cos(time * 0.7) * 25;
  motionData.angleZ = sin(time * 0.3) * 180;
  
  motionData.accelX = sin(time * 2) * 0.5;
  motionData.accelY = cos(time * 1.5) * 0.3;
  motionData.accelZ = 9.81 + sin(time) * 0.2; // Gravity + small variations
  
  motionData.gyroX = sin(time * 3) * 10;
  motionData.gyroY = cos(time * 2.5) * 8;
  motionData.gyroZ = sin(time * 1.8) * 15;
}

/**
 * Check I2C device presence
 * @param address I2C address to check
 * @return true if device responds
 */
bool checkI2CDevice(uint8_t address) {
  Wire.beginTransmission(address);
  return (Wire.endTransmission() == 0);
}

/**
 * Scan and display I2C devices
 */
void scanI2CDevices() {
  Serial.println("Scanning I2C devices...");
  uint8_t deviceCount = 0;
  
  for (uint8_t address = 1; address < 127; address++) {
    if (checkI2CDevice(address)) {
      Serial.print("I2C device found at address 0x");
      if (address < 16) Serial.print("0");
      Serial.println(address, HEX);
      deviceCount++;
    }
  }
  
  if (deviceCount == 0) {
    Serial.println("No I2C devices found");
  } else {
    Serial.print("Found ");
    Serial.print(deviceCount);
    Serial.println(" I2C devices");
  }
}

void setup() {
  Serial.begin(115200);
  Serial.println("\n=== Dual OLED Display Controller ===");
  
  // Initialize I2C
  #ifdef ESP8266
    Wire.begin(4, 5); // ESP8266: SDA=GPIO4, SCL=GPIO5
    Serial.println("I2C initialized for ESP8266 (SDA=4, SCL=5)");
  #elif defined(ESP32)
    Wire.begin(21, 22); // ESP32: SDA=GPIO21, SCL=GPIO22
    Serial.println("I2C initialized for ESP32 (SDA=21, SCL=22)");
  #else
    Wire.begin(); // Arduino: SDA=A4, SCL=A5
    Serial.println("I2C initialized for Arduino");
  #endif
  
  Wire.setClock(400000); // Set I2C clock to 400kHz
  
  delay(100);
  
  // Scan for I2C devices
  scanI2CDevices();
  
  // Check multiplexer
  if (!checkI2CDevice(MUX_I2C_ADDR)) {
    Serial.println("ERROR: I2C Multiplexer not found!");
    Serial.println("Check wiring and addresses");
    while(1) {
      delay(1000);
    }
  }
  Serial.println("I2C Multiplexer found");
  
  // Initialize displays
  bool healthOK = initializeDisplay(healthDisplay, HEALTH_DISPLAY_CHANNEL, "Health Display");
  delay(100);
  bool motionOK = initializeDisplay(motionDisplay, MOTION_DISPLAY_CHANNEL, "Motion Display");
  
  if (!healthOK || !motionOK) {
    Serial.println("ERROR: One or more displays failed to initialize");
    while(1) {
      delay(1000);
    }
  }
  
  Serial.println("All displays initialized successfully");
  Serial.println("Starting main loop...\n");
  
  // Initial display update
  updateHealthDisplay();
  updateMotionDisplay();
}

void loop() {
  unsigned long currentTime = millis();
  
  // Simulate new sensor data
  if (currentTime - lastDataSimulation >= DATA_INTERVAL) {
    simulateSensorData();
    lastDataSimulation = currentTime;
  }
  
  // Update displays
  if (currentTime - lastUpdate >= UPDATE_INTERVAL) {
    updateHealthDisplay();
    updateMotionDisplay();
    lastUpdate = currentTime;
    
    // Debug output
    Serial.print("HR: ");
    Serial.print(healthData.heartRate);
    Serial.print(" BPM, SpO2: ");
    Serial.print(healthData.spO2);
    Serial.print("%, Angle X: ");
    Serial.print(motionData.angleX, 1);
    Serial.print("°, Accel Z: ");
    Serial.print(motionData.accelZ, 2);
    Serial.println(" g");
  }
  
  // Small delay to prevent overwhelming the I2C bus
  delay(10);
}
