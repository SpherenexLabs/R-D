//i,v,soc of battery+ultrasonic triggers < 15cm
// I READING NOT STABLE/CORRECT
// ===== File: smart_vehicle_monitoring.ino =====
#include <Arduino.h>
#include <Wire.h>
#include <ESP8266WiFi.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Firebase_ESP_Client.h>
#include "addons/TokenHelper.h"    // provides tokenStatusCallback
#include "addons/RTDBHelper.h"
#include <math.h>

// ===== Wi-Fi Config =====
#define WIFI_SSID       "rocket"
#define WIFI_PASSWORD   "123456789"

// ===== Firebase Config =====
#define API_KEY         "AIzaSyAhLCi6JBT5ELkAFxTplKBBDdRdpATzQxI"
#define DATABASE_URL    "https://smart-medicine-vending-machine-default-rtdb.asia-southeast1.firebasedatabase.app"
#define USER_EMAIL      "spherenexgpt@gmail.com"
#define USER_PASSWORD   "Spherenex@123"

// ===== Firebase Paths (no spaces) =====  // FIX(1): remove spaces to avoid 400 Bad Request
// ===== Firebase Paths (with vehicle node) =====
// File: smart_vehicle_monitoring.ino  (replace the old path block)
#define FB_ROOT                 "/2_KS5165_Smart_Vechile_monitoring"
#define FB_VEHICLE_NODE         FB_ROOT "/vechicle_2"      // <- subfolder

#define FB_PATH_VOLTAGE         FB_VEHICLE_NODE "/V_in_V"
#define FB_PATH_CURRENT         FB_VEHICLE_NODE "/I_in_mA"
#define FB_PATH_SOC             FB_VEHICLE_NODE "/SOC_percent"
#define FB_PATH_ALERT           FB_VEHICLE_NODE "/alert"
#define FB_PATH_STATUS          FB_VEHICLE_NODE "/__status"

// ===== OLED Config =====
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// ===== Ultrasonic Sensor Pins =====
#define TRIG_PIN D6
#define ECHO_PIN D5
#define SOUND_SPEED 0.034f
#define CRITICAL_CM 15

// ===== Voltage Divider and Battery Settings =====
#define ADC_PIN A0
const float ADC_A0_VMAX = 3.20f;       // NodeMCU A0 max ~3.2 V (board level)
const float R1_TOP_OHMS = 32200.0f;
const float R2_BOT_OHMS = 7500.0f;
const float VOLT_GAIN = 1.0f;
const float VOLT_OFFSET = 0.0f;
const float OFF_THRESHOLD_V = 1.0f;

const int   N_CELLS = 1;
const float R_CELL_OHMS = 0.050f;      // ~50 mΩ/cell nominal
const float R_PACK_OHMS = R_CELL_OHMS * N_CELLS;

const int   ADC_AVG_SAMPLES = 10;
const float VOC_ALPHA_UP = 0.20f, VOC_ALPHA_DN = 0.005f;
const float I_MIN_mA = 0.0f;
const float I_MAX_mA = 2000.0f;

// ===== Timing =====
const uint32_t PRINT_MS = 1000;
float dividerRatio, invDivider, voc_est_V = NAN;

// ===== Firebase Setup =====
FirebaseData fbdo;
FirebaseAuth auth;
FirebaseConfig config;

// ===== OCV Table for SoC =====
struct OcvPoint { float v_cell, soc; };
const OcvPoint OCV_TABLE[] = {
  {3.50f, 0}, {3.60f, 5}, {3.65f, 10}, {3.70f, 20},
  {3.75f, 30}, {3.80f, 40}, {3.85f, 50}, {3.90f, 60},
  {3.95f, 70}, {4.00f, 80}, {4.10f, 90}, {4.20f, 100}
};
const int OCV_N = sizeof(OCV_TABLE) / sizeof(OCV_TABLE[0]);

float estimate_soc_from_pack(float v_pack) {
  float v_cell = v_pack / N_CELLS;
  if (v_cell <= OCV_TABLE[0].v_cell) return 0;
  if (v_cell >= OCV_TABLE[OCV_N - 1].v_cell) return 100;
  for (int i = 0; i < OCV_N - 1; ++i) {
    if (v_cell >= OCV_TABLE[i].v_cell && v_cell <= OCV_TABLE[i + 1].v_cell) {
      float t = (v_cell - OCV_TABLE[i].v_cell) / (OCV_TABLE[i + 1].v_cell - OCV_TABLE[i].v_cell);
      return OCV_TABLE[i].soc + t * (OCV_TABLE[i + 1].soc - OCV_TABLE[i].soc);
    }
  }
  return 0;
}

int read_adc_avg(int samples) {
  long sum = 0;
  for (int i = 0; i < samples; ++i) {
    sum += analogRead(ADC_PIN);
    delay(2);
  }
  return sum / samples;
}

float measure_voltage() {
  int raw = read_adc_avg(ADC_AVG_SAMPLES);
  float v_a0 = (raw / 1023.0f) * ADC_A0_VMAX;
  float v_pack = v_a0 * invDivider * VOLT_GAIN + VOLT_OFFSET;   // include gain/offset
  return v_pack;
}

long measure_distance_cm() {
  digitalWrite(TRIG_PIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH); delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  long dur = pulseIn(ECHO_PIN, HIGH, 30000L);
  return (dur > 0) ? (long)(dur * SOUND_SPEED / 2.0f) : -1;
}

// Robust write with small retry/backoff  // FIX(2): add retry helper
template<typename T>
bool fb_set_number(const char* path, T value) {
  for (int i = 0; i < 3; ++i) {
    if (Firebase.ready() && Firebase.RTDB.set(&fbdo, path, value)) return true;
    delay(150);
  }
  Serial.printf("Firebase write failed (%s): %s\n", path, fbdo.errorReason().c_str());
  return false;
}

void setup() {
  Serial.begin(115200);

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  // OLED Init
  Wire.begin(D2, D1);
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("OLED init failed")); while (1);
  }
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0,0);
  display.println("Booting...");
  display.display();

  // Voltage divider calculation
  dividerRatio = R2_BOT_OHMS / (R1_TOP_OHMS + R2_BOT_OHMS);
  invDivider = 1.0f / dividerRatio;

  // Wi-Fi connect
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to Wi-Fi");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print("."); delay(400);
  }
  Serial.println("\nWi-Fi connected, IP: " + WiFi.localIP().toString());

  // Firebase config
  config.api_key = API_KEY;
  config.database_url = DATABASE_URL;
  config.token_status_callback = tokenStatusCallback;     // FIX(3): see token progress
  config.timeout.serverResponse = 10000;                  // optional

  auth.user.email = USER_EMAIL;
  auth.user.password = USER_PASSWORD;

  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);

  // Wait until auth/token is ready before first write     // FIX(4)
  Serial.print("Waiting for Firebase to be ready");
  uint32_t t0 = millis();
  while (!Firebase.ready()) {
    if (millis() - t0 > 30000) {     // 30s timeout
      Serial.println("\nFirebase not ready (timeout). Check credentials/provider.");
      break;
    }
    Serial.print("."); delay(300);
  }
  Serial.println("\nFirebase ready: " + String(Firebase.ready() ? "yes" : "no"));

  if (Firebase.ready()) {
    fb_set_number(FB_PATH_STATUS, "online");
  }
  display.clearDisplay();
  display.setCursor(0,0);
  display.println("Init OK");
  display.display();
}
void loop() {
  static uint32_t last = millis();
  if (millis() - last < PRINT_MS) return;
  last = millis();

  float v_pack = measure_voltage();
  if (v_pack < OFF_THRESHOLD_V) {
    voc_est_V = NAN;
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Battery too low");
    display.display();
    return;
  }

  // OCV estimator
  if (isnan(voc_est_V)) voc_est_V = v_pack;
  if (v_pack > voc_est_V)
    voc_est_V += VOC_ALPHA_UP * (v_pack - voc_est_V);
  else
    voc_est_V += VOC_ALPHA_DN * (v_pack - voc_est_V);
  // Current estimate via internal resistance
  float I_mA = ((voc_est_V - v_pack) / R_PACK_OHMS) * 1000.0f;   // FIX(5): divide by R, convert to mA
  if (I_mA < I_MIN_mA) I_mA = I_MIN_mA;
  if (I_mA > I_MAX_mA) I_mA = I_MAX_mA;
  if (fabsf(I_mA) < 1.0f) I_mA = 0.0f;                           // small values → 0
  float soc = estimate_soc_from_pack(voc_est_V);
  long dist = measure_distance_cm();
  int alert = (dist >= 0 && dist <= CRITICAL_CM) ? 1 : 0;
  // ===== OLED Display =====
  display.clearDisplay();
  display.setCursor(0, 0);
  display.printf("V=%.2fV I=%.0fmA\nSoC=%.0f%%\nDist=%ldcm\n", v_pack, I_mA, soc, dist);
  if (alert) {
    display.setCursor(0, 40);
    display.setTextSize(1);
    display.println("TOO CLOSE!");
  }
  display.display();
  // ===== Firebase Send (only if ready) =====           // FIX(6): gate on ready
  if (WiFi.status() == WL_CONNECTED && Firebase.ready()) {
    fb_set_number(FB_PATH_VOLTAGE, v_pack);
    fb_set_number(FB_PATH_CURRENT, I_mA);
    fb_set_number(FB_PATH_SOC, soc);
    fb_set_number(FB_PATH_ALERT, alert);
  } else {
    Serial.println("Skip send: Wi-Fi or Firebase not ready");
  }
  // ===== Debug Print =====
  Serial.printf("V=%.2fV I=%.0fmA SoC=%.0f%% Dist=%ldcm Alert=%d\n", v_pack, I_mA, soc, dist, alert);
}

