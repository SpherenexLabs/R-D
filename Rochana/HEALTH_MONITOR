#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_MPU6050.h>
#include <DHT.h>
#include <MAX30105.h>
#include "spo2_algorithm.h"
#include <math.h>

// ===== WiFi + HTTPS (Sheets) =====
#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecure.h>

// -------- Wi-Fi --------
#define WIFI_SSID       "spherenex1"
#define WIFI_PASSWORD   "Spherenex@789"

// -------- Apps Script Web App URL (Deploy → copy URL here) --------
const char* SCRIPT_URL = "https://script.google.com/macros/s/AKfycbwK26qIfPvrXKUdPMj9RP5J0y6ejquaceXWB-GwADrtLnaGabSm2L8rtmMJrEUs0z4Mgw/exec";

// ================== OLED ==================
#define OLED_ADDR   0x3C
#define OLED_SDA    D2
#define OLED_SCL    D1
#define OLED_RST    -1
#define OLED_W      128
#define OLED_H      64
Adafruit_SSD1306 oled(OLED_W, OLED_H, &Wire, OLED_RST);

// ================== DHT11 =================
#define DHTPIN  D4
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// ================== MAX3010x ==============
MAX30105 mx;
bool mx_ok = false;
#define BUF_LEN 100
static uint32_t irBuf[BUF_LEN], redBuf[BUF_LEN];
static int bufPos = 0;
int32_t spo2_alg = 0, heart_alg = 0;
int8_t  spo2_valid = 0, hr_valid = 0;
float   hr_ema = NAN, spo2_ema = NAN;
float   last_hr = NAN, last_spo2 = NAN;
bool    finger_ok = false;
uint32_t latest_ir = 0;

const uint32_t FINGER_DC_MIN = 22000;
const uint32_t FINGER_AC_MIN = 3500;
const float    HR_EMA_A = 0.25f;
const float    SPO2_EMA_A = 0.20f;

// ================== MPU6050 ===============
Adafruit_MPU6050 mpu;
bool mpu_ok = false;

const float G = 9.80665f;
const float IMPACT_G      = 0.5f;
const float TILT_DEG      = 60.0f;
const uint32_t IMPACT_WIN_MS = 700;
const uint32_t FALL_LATCH_MS = 5000;

enum FallState { IDLE, IMPACT_SEEN };
FallState fall_state = IDLE;
uint32_t  impact_t0 = 0;
bool      fall_latched = false;
uint32_t  fall_latch_until = 0;

// ================== Buttons (pull-up, press→LOW) ===============
#define BTN_EMERGENCY   D5
#define BTN_HEALTH      D6
#define BTN_SAFE        D7
#define BTN_FAMILY      D3

struct Debounce { uint8_t pin; uint32_t lastMs; bool state; bool lastRaw; };
Debounce db_emg{BTN_EMERGENCY, 0, false, true};
Debounce db_hlp{BTN_HEALTH,    0, false, true};
Debounce db_safe{BTN_SAFE,     0, false, true};
Debounce db_fam{BTN_FAMILY,    0, false, true};

const uint16_t DB_MS = 25;

// ================== Timers =================
uint32_t t_disp = 0, t_algo = 0, t_log = 0, t_sheet = 0;
const uint32_t DISP_MS = 500;
const uint32_t ALGO_MS = 1000;
const uint32_t LOG_MS  = 1000;
const uint32_t SHEET_MS = 1000;   // post to sheet every 1s

// ================== Helpers =================
inline bool  validf(float x){ return !isnan(x) && x > 0; }
inline float ema   (float p,float s,float a){ return validf(p)?(a*s+(1-a)*p):s; }

static void compute_dc_ac(const uint32_t *x, int n, uint32_t &dc, uint32_t &pp){
  uint64_t sum=0; uint32_t mn=UINT32_MAX, mxv=0;
  for(int i=0;i<n;i++){ uint32_t v=x[i]; sum+=v; if(v<mn) mn=v; if(v>mxv) mxv=v; }
  dc=(uint32_t)(sum/(uint64_t)n); pp=(mxv>mn)?(mxv-mn):0;
}

static void read_mpu(float &gmag, float &pitch_deg, float &roll_deg){
  sensors_event_t a,g,t; mpu.getEvent(&a,&g,&t);
  float ax=a.acceleration.x, ay=a.acceleration.y, az=a.acceleration.z;
  float am=sqrtf(ax*ax+ay*ay+az*az); gmag=am/G;
  pitch_deg = atan2f(ax, sqrtf(ay*ay+az*az))*180.0f/PI;
  roll_deg  = atan2f(ay, az)*180.0f/PI;
}

static void deb_update(Debounce &d){
  bool raw=(digitalRead(d.pin)==LOW); uint32_t now=millis();
  if(raw!=d.lastRaw){ d.lastMs=now; d.lastRaw=raw; }
  if((now-d.lastMs)>=DB_MS){ d.state=raw; }
}

static void estimate_bp(int hr, int spo2, int &sys, int &dia){
  float s=118.0f,d=76.0f;
  if(hr>100){ s+=6; d+=3; } else if(hr>0 && hr<55){ s-=5; d-=3; }
  if(spo2>0 && spo2<93){ s+=6; d+=3; } else if(spo2>98){ s-=3; }
  s=constrain(s,90.0f,150.0f); d=constrain(d,55.0f,100.0f);
  sys=(int)(s+0.5f); dia=(int)(d+0.5f);
}

// ===== WiFi =====
static void wifiBegin(){
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  uint32_t t0=millis();
  while(WiFi.status()!=WL_CONNECTED && (millis()-t0)<15000){ delay(250); yield(); }
}

// ===== Send one row to Google Sheet (via Apps Script) =====
bool sendToSheet(int hr, int spo2, int sys, int dia,
                 float angle_deg, bool impact,
                 float tC, float hum)
{
  if(WiFi.status()!=WL_CONNECTED) return false;

  String bp = (sys>0 && dia>0) ? (String(sys)+"/"+String(dia)) : "";

  // build JSON
  String json = "{";
  json += "\"hr\":"        + String(hr)            + ",";
  json += "\"bp\":\""      + bp                      + "\",";
  json += "\"spo2\":"      + String(spo2)           + ",";
  json += "\"angle\":"     + String(angle_deg,1)    + ",";
  json += "\"impact\":"    + String(impact?1:0)     + ",";
  json += "\"temp\":"      + (isnan(tC)?String(""):String(tC,1)) + ",";
  json += "\"humidity\":"  + (isnan(hum)?String(""):String(hum,0));
  json += "}";

  WiFiClientSecure client; 
  client.setInsecure();          // skip cert validation (ESP8266)
  HTTPClient http;
  if(!http.begin(client, SCRIPT_URL)) return false;
  http.addHeader("Content-Type", "application/json");

  int code = http.POST(json);
  String resp = http.getString();
  http.end();

  if(code==200 && resp.indexOf("OK")>=0) return true;
  Serial.printf("Sheet POST code=%d body=%s\n", code, resp.c_str());
  return false;
}

// ================== setup / loop ==================
void setup(){
  Serial.begin(115200); delay(150);
  wifiBegin();

  Wire.begin(OLED_SDA, OLED_SCL); Wire.setClock(400000);
  if(!oled.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR)){ Serial.println(F("SSD1306 fail")); for(;;); }
  oled.clearDisplay(); oled.setTextSize(1); oled.setTextColor(SSD1306_WHITE);
  oled.setCursor(0,0); oled.println("Wearable init..."); oled.display();

  dht.begin();

  mx_ok = mx.begin(Wire, 400000);
  if(mx_ok){
    mx.setup(60,4,2,100,411,4096);
    mx.setPulseAmplitudeIR(0x7F);
    mx.setPulseAmplitudeRed(0x2F);
    int filled=0; uint32_t t0=millis();
    while(filled<BUF_LEN && (millis()-t0)<1500){
      mx.check();
      while(mx.available() && filled<BUF_LEN){
        redBuf[filled]=mx.getFIFORed();
        irBuf[filled] =mx.getFIFOIR();
        latest_ir=irBuf[filled];
        mx.nextSample(); filled++;
      }
      delay(2); yield();
    }
  }else{
    Serial.println("MAX3010x not found.");
  }

  mpu_ok = mpu.begin();
  if(mpu_ok){
    mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
    mpu.setGyroRange(MPU6050_RANGE_500_DEG);
    mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);
  }else{
    Serial.println("MPU6050 not found.");
  }

  pinMode(BTN_EMERGENCY, INPUT_PULLUP);
  pinMode(BTN_HEALTH,    INPUT_PULLUP);
  pinMode(BTN_SAFE,      INPUT_PULLUP);
  pinMode(BTN_FAMILY,    INPUT_PULLUP);

  Serial.println("t_ms,HR,SpO2,TempC,Hum,IR_mean,IR_pp,Finger,Fall,g,Pitch,Roll");
}

void loop(){
  const uint32_t now = millis();

  // Buttons (still available for your logic if needed)
  deb_update(db_emg); deb_update(db_hlp); deb_update(db_safe); deb_update(db_fam);

  // MAX3010x pipeline (same as before)
  if(mx_ok){
    mx.check();
    while(mx.available()){
      redBuf[bufPos]=mx.getFIFORed();
      irBuf[bufPos] =mx.getFIFOIR();
      latest_ir=irBuf[bufPos];
      bufPos=(bufPos+1)%BUF_LEN;
      mx.nextSample();
    }
    if(now - t_algo >= ALGO_MS){
      uint32_t irTmp[BUF_LEN], redTmp[BUF_LEN];
      for(int i=0;i<BUF_LEN;i++){ int idx=(bufPos+i)%BUF_LEN; irTmp[i]=irBuf[idx]; redTmp[i]=redBuf[idx]; }
      uint32_t dc=0, pp=0; compute_dc_ac(irTmp, BUF_LEN, dc, pp);
      finger_ok = (dc>=FINGER_DC_MIN) && (pp>=FINGER_AC_MIN);

      maxim_heart_rate_and_oxygen_saturation(irTmp, BUF_LEN, redTmp,
                                             &spo2_alg,&spo2_valid,&heart_alg,&hr_valid);
      if(finger_ok && hr_valid && heart_alg>0){ hr_ema=ema(hr_ema,(float)heart_alg,HR_EMA_A); last_hr=hr_ema; }
      else { last_hr=NAN; hr_ema=NAN; }

      if(finger_ok && spo2_valid && spo2_alg>0){ spo2_ema=ema(spo2_ema,(float)spo2_alg,SPO2_EMA_A); last_spo2=spo2_ema; }
      else { last_spo2=NAN; spo2_ema=NAN; }

      t_algo = now;
    }
  }

  // DHT11
  float humidity = dht.readHumidity();
  float temperature = dht.readTemperature();

  // MPU6050 & fall detection
  float gmag=NAN, pitch=NAN, roll=NAN;
  if(mpu_ok){
    read_mpu(gmag, pitch, roll);
    switch(fall_state){
      case IDLE: if(gmag>IMPACT_G){ fall_state=IMPACT_SEEN; impact_t0=now; } break;
      case IMPACT_SEEN:
        if(now-impact_t0<=IMPACT_WIN_MS){
          if(fabsf(pitch)>=TILT_DEG || fabsf(roll)>=TILT_DEG){
            fall_latched=true; fall_latch_until=now+FALL_LATCH_MS; fall_state=IDLE;
          }
        }else fall_state=IDLE;
        break;
    }
    if(fall_latched && now>=fall_latch_until) fall_latched=false;
  }

  // Derived values for display / sheet
  int hr_out  = (validf(last_hr)   ? constrain((int)(last_hr+0.5f), 40, 180) : 0);
  int s2_out  = (validf(last_spo2) ? constrain((int)(last_spo2+0.5f), 85, 100) : 0);
  int bp_sys=0, bp_dia=0; if(hr_out>0 && s2_out>0) estimate_bp(hr_out, s2_out, bp_sys, bp_dia);
  float angle_deg = (isnan(pitch)||isnan(roll)) ? NAN : max(fabsf(pitch), fabsf(roll));

  // OLED: HR/BP/SPO2/Angle/Impact/Temp/Humidity
  if(now - t_disp >= DISP_MS){
    oled.clearDisplay(); oled.setTextSize(1); oled.setTextColor(SSD1306_WHITE);

    oled.setCursor(0,0);
    oled.print("HR:");   if(hr_out>0){ oled.print(hr_out); } else { oled.print("--"); }
    oled.print("  SpO2:"); if(s2_out>0){ oled.print(s2_out); oled.print("%"); } else { oled.print("--"); }

    oled.setCursor(0,12);
    if(bp_sys>0) { oled.print("BP: "); oled.print(bp_sys); oled.print("/"); oled.print(bp_dia); }
    else         { oled.print("BP: --/--"); }

    oled.setCursor(0,24);
    oled.print("Angle: ");
    if(!isnan(angle_deg)) { oled.print(angle_deg,1); oled.print(" deg"); } else oled.print("--");

    oled.setCursor(0,36);
    oled.print("Impact: "); oled.print(fall_latched ? 1 : 0);

    oled.setCursor(0,48);
    if(!isnan(temperature) && !isnan(humidity)){
      oled.print("T:"); oled.print(temperature,1);
      oled.print("C  H:"); oled.print((int)humidity); oled.print("%");
    }else{
      oled.print("T/H: NA");
    }

    oled.display();
    t_disp = now;
  }

  // Periodic POST to Google Sheet
  if(now - t_sheet >= SHEET_MS){
    t_sheet = now;
    sendToSheet(hr_out, s2_out, bp_sys, bp_dia,
                angle_deg, fall_latched,
                temperature, humidity);
  }

  yield();
}
